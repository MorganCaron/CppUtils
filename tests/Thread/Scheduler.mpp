export module CppUtils.UnitTests.Thread.Scheduler;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Thread::Scheduler
{
	inline auto _ = TestSuite{
		"Thread/Scheduler", {"UnitTest"}, []([[maybe_unused]] auto& suite) {
		using namespace std::chrono_literals;

		suite.addTest("Initialize Scheduler", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};

			scheduler.waitUntilFinished();
		});

		suite.addTest("Schedule and execute", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto executed = std::atomic_bool{false};

			scheduler.schedule([&executed] {
				executed = true;
			}, 100ms);

			scheduler.waitUntilFinished();

			suite.expect(executed.load());
		});

		suite.addTest("Recursive scheduling", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto counter = std::atomic_size_t{0};

			scheduler.schedule([&scheduler, &counter] {
				++counter;
				scheduler.schedule([&counter] {
					++counter;
				}, 100ms);
			}, 100ms);

			scheduler.waitUntilFinished();

			suite.expectEqual(counter.load(), 2uz);
		});

		suite.addTest("Cancel tasks on destruction", [&] {
			auto executed = std::atomic_bool{false};

			{
				auto scheduler = CppUtils::Thread::Scheduler{};

				scheduler.schedule([&executed] {
					executed = true;
				}, 100ms);
			}

			suite.expect(not executed.load());
		});

		suite.addTest("Multiple tasks", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto counter = std::atomic_size_t{0};

			scheduler.schedule([&counter] { ++counter; }, 100ms);
			scheduler.schedule([&counter] { ++counter; }, 200ms);
			scheduler.schedule([&counter] { ++counter; }, 300ms);

			scheduler.waitUntilFinished();

			suite.expectEqual(counter.load(), 3uz);
		});

		suite.addTest("Cancel specific task", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto number = std::atomic_size_t{0};

			scheduler.schedule([&number] { ++number; }, 0ms);
			const auto id = scheduler.schedule([&number] { number += 0b10; }, 250ms);
			scheduler.schedule([&number] { number += 0b100; }, 500ms);

			scheduler.cancel(id);

			scheduler.waitUntilFinished();

			suite.expectEqual(number.load(), 5uz);
		});

		suite.addTest("Cancel all tasks", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto number = std::atomic_size_t{0};

			scheduler.schedule([&number] { ++number; }, 0ms);
			scheduler.schedule([&number] { number += 0b10; }, 250ms);
			scheduler.schedule([&number] { number += 0b100; }, 500ms);

			scheduler.cancelAll();

			scheduler.waitUntilFinished();

			suite.expectEqual(number.load(), 0uz);
		});

		suite.addTest("Order of execution", [&] {
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto executionOrder = std::vector<std::size_t>{};
			auto record = [&](std::size_t value) { executionOrder.push_back(value); };

			scheduler.schedule([&] { record(1); }, 100ms);
			scheduler.schedule([&] { record(2); }, 50ms);
			scheduler.schedule([&] { record(3); }, 200ms);

			scheduler.waitUntilFinished();

			suite.expectEqual(executionOrder[0], 2uz);
			suite.expectEqual(executionOrder[1], 1uz);
			suite.expectEqual(executionOrder[2], 3uz);
		});

		suite.addTest("Without bucketing", [&] {
			using Clock = CppUtils::Thread::Scheduler::Clock;
			using TimePoint = CppUtils::Thread::Scheduler::TimePoint;
			auto scheduler = CppUtils::Thread::Scheduler{};
			auto times = std::vector<TimePoint>{};

			auto record = [&](TimePoint timePoint) { times.push_back(timePoint); };

			scheduler.schedule([&] { record(Clock::now()); }, 100ms);
			scheduler.schedule([&] { record(Clock::now()); }, 250ms);
			scheduler.schedule([&] { record(Clock::now()); }, 300ms);
			scheduler.schedule([&] { record(Clock::now()); }, 700ms);

			scheduler.waitUntilFinished();

			suite.expect(times[1] - times[0] > 100ms);
			suite.expect(times[2] - times[1] < 100ms);
			suite.expect(times[3] - times[2] > 200ms);
		});

		suite.addTest("With bucketing", [&] {
			using Clock = CppUtils::Thread::Scheduler::Clock;
			using TimePoint = CppUtils::Thread::Scheduler::TimePoint;
			auto scheduler = CppUtils::Thread::Scheduler{200ms};
			auto times = std::vector<TimePoint>{};

			auto record = [&](TimePoint timePoint) { times.push_back(timePoint); };

			scheduler.schedule([&] { record(Clock::now()); }, 100ms);
			scheduler.schedule([&] { record(Clock::now()); }, 250ms);
			scheduler.schedule([&] { record(Clock::now()); }, 300ms);
			scheduler.schedule([&] { record(Clock::now()); }, 700ms);

			scheduler.waitUntilFinished();

			suite.expect(times[1] - times[0] < 100ms);
			suite.expect(times[2] - times[1] > 100ms);
			suite.expect(times[3] - times[2] > 200ms);
		});
	}};
}

export module CppUtils.UnitTests.Thread.ThreadPool;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Thread::ThreadPool
{
	inline auto _ = CppUtils::UnitTest::TestSuite{"Thread/ThreadPool", {"UnitTest"}, [](auto& suite) {
		using namespace std::literals;
		using namespace std::chrono_literals;
		using Logger = CppUtils::Logger<"CppUtils">;

		suite.addTest("0 task / 1 thread", [&] {
			auto _ = CppUtils::Thread::ThreadPool{1};
		});

		suite.addTest("0 task / 2 threads", [&] {
			auto _ = CppUtils::Thread::ThreadPool{2};
		});

		suite.addTest("0 task / N threads", [&] {
			auto _ = CppUtils::Thread::ThreadPool{};
		});

		suite.addTest("1 task with future.wait()", [&] {
			auto called = std::atomic_bool{false};
			{
				auto threadPool = CppUtils::Thread::ThreadPool{};
				auto future = threadPool.call([&called] {
					called = true;
				});
				future.wait();
			}
			suite.expect(called);
		});

		suite.addTest("waitUntilFinished", [&] {
			auto called = std::atomic_bool{false};
			{
				auto threadPool = CppUtils::Thread::ThreadPool{};
				threadPool.call([&called] {
					called = true;
				});
				threadPool.waitUntilFinished();
			}
			suite.expect(called);
		});

		suite.addTest("Error handling with future", [&] {
			auto threadPool = CppUtils::Thread::ThreadPool{};
			auto future = threadPool.call([] {
				throw std::runtime_error{"Test error"};
			});

			auto called = std::atomic_bool{false};
			try
			{
				future.get();
			}
			catch (const std::exception& exception)
			{
				called = true;
				Logger::print<"error">("ThreadPool: Unhandled exception: {}", exception.what());
				suite.expectEqual(exception.what(), "Test error"sv);
			}
			suite.expect(called);
		});

		suite.addTest("Error handling without future", [&] {
			auto threadPool = CppUtils::Thread::ThreadPool{};
			auto called = std::atomic_bool{false};
			threadPool.setOnError([&suite, &called](std::exception_ptr exceptionPointer) {
				called = true;
				try
				{
					std::rethrow_exception(exceptionPointer);
				}
				catch (const std::exception& exception)
				{
					Logger::print<"error">("ThreadPool: Unhandled exception: {}", exception.what());
					suite.expectEqual(exception.what(), "Test error"sv);
				}
				catch (...)
				{
					Logger::print<"error">("ThreadPool: Unhandled non-std exception");
				}
			});
			threadPool.call([] {
				throw std::runtime_error{"Test error"};
			});
			threadPool.waitUntilFinished();
			suite.expect(called);
		});
	}};
}

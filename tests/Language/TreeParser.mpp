export module CppUtils.UnitTests.Language.TreeParser;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Language::TreeParser
{
	inline auto _ = TestSuite{
		"Language/TreeParser",
		{"Logger", "Container/Tree", "Language/MetaCircularEvaluator"},
		[](auto& suite) {
		using namespace std::literals;
		using namespace CppUtils::String::Literals;
		using Logger = CppUtils::Logger<"CppUtils">;

		suite.addTest("Empty source", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = ""sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			suite.expect(std::empty(interpreter.getScope().nodes));
		});

		suite.addTest("Whitespaces", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = R"(

			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			suite.expect(std::empty(interpreter.getScope().nodes));
		});

		suite.addTest("Parse token", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = "parent"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 0uz);
		});

		suite.addTest("Empty node", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = "parent{}"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 0uz);
		});

		suite.addTest("Escaped char", [&] {
			// Todo
			[[maybe_unused]] constexpr auto source = R"(Hello\ World{})"sv;
		});

		suite.addTest("Parse value", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = R"(
				'a
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, static_cast<String::Token>('a'));
		});

		suite.addTest("Nested nodes", [&] {
			auto interpreter = CppUtils::Language::TreeParser{};
			constexpr auto source = R"(
				parent {
					child1
					child2
				}
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 2uz);
			suite.expectEqual(scopeNodes.front().nodes.at(0).value, "child1"_token);
			suite.expectEqual(scopeNodes.front().nodes.at(1).value, "child2"_token);
		});
	}};
}

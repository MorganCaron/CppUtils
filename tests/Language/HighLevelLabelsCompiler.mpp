export module CppUtils.UnitTests.Language.HighLevelLabelsCompiler;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Language::HighLevelLabelsCompiler
{
	inline auto _ = TestSuite{"Language/HighLevelLabelsCompiler", []([[maybe_unused]] auto& suite) {
		using namespace std::literals;
		using Logger = CppUtils::Logger<"CppUtils">;
		namespace VM = CppUtils::Language::VirtualMachine;
		namespace Compiler = CppUtils::Language::HighLevelLabelsCompiler;

		suite.addTest("empty source", [&] {
			constexpr auto source = u"{X}"sv;
			auto output = Compiler::compile(source);
			Logger::print("Output:\n{}\n", CppUtils::String::toAscii(output));

			auto executionResult = VM::execute<std::size_t>(output);
			suite.expectEqual(executionResult, 0uz);
		});

		suite.addTest("one function", [&] {
			constexpr auto source = uR"(
				(21X

				main {
					42X
				}

				(22X
				)"sv;
			auto output = Compiler::compile(source);
			Logger::print("Output:\n{}\n", CppUtils::String::toAscii(output));

			auto executionResult = VM::execute<std::size_t>(output);
			suite.expectEqual(executionResult, 42uz);
		});

		suite.addTest("comment", [&] {
			constexpr auto source = uR"(
					main {
						4
						# Comment: (),+-*/%=<>!:;?§¤@\1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ
						2X
					}
				)"sv;
			auto output = Compiler::compile(source);
			Logger::print("Output:\n{}\n", CppUtils::String::toAscii(output));

			auto executionResult = VM::execute<std::size_t>(output);
			suite.expectEqual(executionResult, 42uz);
		});

		suite.addTest("call function", [&] constexpr {
			constexpr auto source = uR"(
				(21X

				main {
					# Call return40 function
					(: (1@ # <- return 40

					# Add 2
					(0, 2, 0+
					X
				}

				(22X

				return40 {
					40
				}

				(23X
				)"sv;
			auto output = Compiler::compile(source);
			Logger::print("Output:\n{}\n", CppUtils::String::toAscii(output));

			auto executionResult = VM::execute<std::size_t>(output);
			suite.expectEqual(executionResult, 42uz);
		});
	}};
}

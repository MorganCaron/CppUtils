export module CppUtils.UnitTests.Language.ASTParser;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Language::ASTParser
{
	inline auto _ = TestSuite{
		"Language/ASTParser",
		{"Logger", "Container/Tree", "Language/MetaEvaluator"},
		[](auto& suite) {
		using namespace std::literals;
		using namespace CppUtils::String::Literals;
		using Logger = CppUtils::Logger<"CppUtils">;

		static constexpr auto addStack = [](CppUtils::Language::ASTParser& interpreter) {
			using ASTNode = CppUtils::Language::ASTNode;
			auto& mainNode = interpreter.rootAst["main"_token];
			// clang-format off
			mainNode.nodes.insert(std::begin(mainNode.nodes), {
				ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{"stack"_token}}}}},
				ASTNode{"call"_token, {ASTNode{"enterInLast"_token}}}
			});
			// clang-format on
		};

		suite.addTest("Empty source", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = ""sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			suite.expect(std::empty(interpreter.getScope().nodes));
		});

		suite.addTest("Whitespaces", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = R"(

			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			suite.expect(std::empty(interpreter.getScope().nodes));
		});

		suite.addTest("Parse token", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = "parent"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 0uz);
		});

		suite.addTest("Empty node", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = "parent{}"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 0uz);
		});

		suite.addTest("Escaped char", [&] {
			// Todo
			[[maybe_unused]] constexpr auto source = R"(Hello\ World{})"sv;
		});

		suite.addTest("Parse value", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = R"(
				'a'
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, static_cast<String::Token>('a'));
		});

		suite.addTest("Nested nodes", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = R"(
				parent {
					child1
					child2
				}
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "parent"_token);
			suite.expectEqual(std::size(scopeNodes.front().nodes), 2uz);
			suite.expectEqual(scopeNodes.front().nodes.at(0).value, "child1"_token);
			suite.expectEqual(scopeNodes.front().nodes.at(1).value, "child2"_token);
		});

		suite.addTest("Run function", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = R"(
				run {
					call{new{createNode}}
				}
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 2uz);
			suite.expectEqual(scopeNodes.at(0).value, "run"_token);
			suite.expectEqual(scopeNodes.at(1).value, "createNode"_token);
		});

		suite.addTest("Run temporary function", [&] {
			auto interpreter = CppUtils::Language::ASTParser{};
			addStack(interpreter);
			constexpr auto source = R"(
				run {
					call{new{createNode}}
					call{delete{run}}
				}
			)"sv;
			auto cursor = CppUtils::String::Cursor{source};

			auto result = interpreter(cursor);
			if (not result)
				Logger::print<"error">("Error: {}\nPosition: {}\nChar: '{}'", result.error(), cursor.position, cursor.getCurrent());

			suite.expect(result.has_value());
			std::println("{}", interpreter.getScope());
			const auto& scopeNodes = interpreter.getScope().nodes;
			suite.expectEqual(std::size(scopeNodes), 1uz);
			suite.expectEqual(scopeNodes.front().value, "createNode"_token);
		});
	}};
}

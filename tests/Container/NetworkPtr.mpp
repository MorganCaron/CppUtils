export module CppUtils.UnitTests.Container.NetworkPtr;

import std;
import CppUtils;

namespace CppUtils::UnitTest::Container::NetworkPtr
{
	auto _ = TestSuite{"Container/NetworkPtr", {"Logger"}, [](auto& suite) {
		using Logger = CppUtils::Logger<"CppUtils">;
		using NetworkPtr = CppUtils::Container::NetworkPtr<DummyObject>;
		using StringNetworkPtr = CppUtils::Container::NetworkPtr<std::string>;

		suite.addTest("Create root", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto accessor = root->sharedAccess();
			suite.expectEqual(accessor->getDistanceFromRoot(), 0uz);
		});

		suite.addTest("Create node", [&] {
			auto node = NetworkPtr::make("Node");
			auto accessor = node->sharedAccess();
			suite.expectEqual(accessor->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
		});

		suite.addTest("Read value", [&] {
			auto node = StringNetworkPtr::make("Node");
			{
				auto accessor = node->sharedAccess();
				suite.expectEqual(accessor->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
				suite.expectEqual(accessor->value, "Node");
			}
		});

		suite.addTest("Write value", [&] {
			auto node = StringNetworkPtr::make("Node");
			{
				auto accessor = node->uniqueAccess();
				accessor->value = "Changed";
			}
			{
				auto accessor = node->sharedAccess();
				suite.expectEqual(accessor->value, "Changed");
			}
		});

		suite.addTest("Create branch", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				suite.expectEqual(branchRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
				rootRef.attachChild(branch, branchRef);
				suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
			}
			Logger::print("Persistance de Branch\n");
		});

		suite.addTest("Create leaf", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
					auto& rootRef = std::get<0>(accessor.values);
					auto& branchRef = std::get<1>(accessor.values);
					rootRef.attachChild(branch, branchRef);
					suite.expectEqual(rootRef.getDistanceFromRoot(), 0uz);
					suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
				}
				{
					auto leaf = NetworkPtr::make("Leaf", 2uz);
					auto accessor = CppUtils::Thread::MultipleAccessor{*branch, *leaf};
					auto& branchRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					branchRef.attachChild(leaf, leafRef);
					suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
					suite.expectEqual(leafRef.getDistanceFromRoot(), 2uz);
				}
				Logger::print("Persistance de Leaf\n");
			}
			Logger::print("Persistance de Branch\n");
		});

		suite.addTest("Cut leaf", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto leaf = NetworkPtr::make("Leaf", 1uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *leaf};
					auto& rootRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					suite.expectEqual(leafRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
					rootRef.attachChild(leaf, leafRef);
					suite.expectEqual(leafRef.getDistanceFromRoot(), 1uz);
				}
				Logger::print("Persistance de Leaf\n");
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *leaf};
				auto& rootRef = std::get<0>(accessor.values);
				auto& leafRef = std::get<1>(accessor.values);
				suite.expectEqual(leafRef.getDistanceFromRoot(), 1uz);
				rootRef.detachChild(leaf, leafRef);
				suite.expectEqual(leafRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
			}
			Logger::print("Non-persistance de Leaf\n");
		});

		suite.addTest("Cut branch with leaf", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				auto leaf = NetworkPtr::make("Leaf", 2uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
					auto& rootRef = std::get<0>(accessor.values);
					auto& branchRef = std::get<1>(accessor.values);
					rootRef.attachChild(branch, branchRef);
				}
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*branch, *leaf};
					auto& branchRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					branchRef.attachChild(leaf, leafRef);
				}
				Logger::print("Persistance de Leaf\n");
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
				rootRef.detachChild(branch, branchRef);
				suite.expectEqual(branchRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());

				{
					auto leafAccessor = leaf->sharedAccess();
					suite.expectEqual(leafAccessor->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
				}
			}
			Logger::print("Non-persistance de Branch\n");
		});

		suite.addTest("Bidirectional link", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto branch = CppUtils::Container::SafeShared<NetworkPtr>{};
			{
				branch = NetworkPtr::make("Branch", 1uz);
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				rootRef.attachChild(branch, branchRef);
				suite.expectEqual(rootRef.getDistanceFromRoot(), 0uz);
				suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
			}
			Logger::print("Persistance de Branch\n");
			{
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				Logger::print("Création d'une boucle\n");
				branchRef.attachChild(root, rootRef);
				suite.expectEqual(rootRef.getDistanceFromRoot(), 0uz);
				suite.expectEqual(branchRef.getDistanceFromRoot(), 1uz);
			}
			Logger::print("Libération de la boucle\n");
		});

		suite.addTest("Detach child with multiple links", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto leaf = NetworkPtr::make("Leaf", 1uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *leaf};
					auto& rootRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					suite.expectEqual(leafRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());

					rootRef.attachChild(leaf, leafRef);
					suite.expectEqual(leafRef.getDistanceFromRoot(), 1uz);

					rootRef.attachChild(leaf, leafRef);
					suite.expectEqual(leafRef.getDistanceFromRoot(), 1uz);

					rootRef.detachChild(leaf, leafRef);
					suite.expectEqual(leafRef.getDistanceFromRoot(), 1uz);

					rootRef.detachChild(leaf, leafRef);
					suite.expectEqual(leafRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
				}
				Logger::print("Non-persistance de Leaf\n");
			}
			Logger::print("Persistance de Branch\n");
		});

		suite.addTest("Attach and detach root on itself", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto accessor = root->uniqueAccess();
			accessor->attachChild(root, accessor.value());
			suite.expectEqual(accessor->getDistanceFromRoot(), 0uz);
			accessor->detachChild(root, accessor.value());
			suite.expectEqual(accessor->getDistanceFromRoot(), 0uz);
		});

		suite.addTest("Attach and detach node on itself", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto node = NetworkPtr::make("Node", 1uz);
			{
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *node};
				auto& rootRef = std::get<0>(accessor.values);
				auto& nodeRef = std::get<1>(accessor.values);
				rootRef.attachChild(node, nodeRef);
				suite.expectEqual(nodeRef.getDistanceFromRoot(), 1uz);
			}
			{
				auto accessor = node->uniqueAccess();
				accessor->attachChild(node, accessor.value());
				suite.expectEqual(accessor->getDistanceFromRoot(), 1uz);
				accessor->detachChild(node, accessor.value());
				suite.expectEqual(accessor->getDistanceFromRoot(), 1uz);
			}
			{
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *node};
				auto& rootRef = std::get<0>(accessor.values);
				auto& nodeRef = std::get<1>(accessor.values);
				rootRef.detachChild(node, nodeRef);
				suite.expectEqual(nodeRef.getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
			}
		});

		suite.addTest("Unidirectional link (operator>>)", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto child = NetworkPtr::make("Child", 1uz);

			root >> child;

			auto childAccessor = child->sharedAccess();
			suite.expectEqual(childAccessor->getDistanceFromRoot(), 1uz);
		});

		suite.addTest("Unidirectional link chaining (operator>>)", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto branch = NetworkPtr::make("Branch", 1uz);
			auto leaf = NetworkPtr::make("Leaf", 2uz);

			root >> branch >> leaf;

			{
				auto branchAccessor = branch->sharedAccess();
				suite.expectEqual(branchAccessor->getDistanceFromRoot(), 1uz);
			}
			{
				auto leafAccessor = leaf->sharedAccess();
				suite.expectEqual(leafAccessor->getDistanceFromRoot(), 2uz);
			}
		});

		suite.addTest("Unlink (operator-)", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto child = NetworkPtr::make("Child");
			root >> child;
			{
				auto childAccessor = child->sharedAccess();
				suite.expectEqual(childAccessor->getDistanceFromRoot(), 1uz);
			}

			root - child;

			auto childAccessor = child->sharedAccess();
			suite.expectEqual(childAccessor->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
		});

		suite.addTest("Bidirectional link (operator&)", [&] {
			auto node1 = NetworkPtr::makeRoot("Node1");
			auto node2 = NetworkPtr::make("Node2");

			node1 & node2;

			auto node1Accessor = node1->sharedAccess();
			auto node2Accessor = node2->sharedAccess();
			suite.expectEqual(node1Accessor->getDistanceFromRoot(), 0uz);
			suite.expectEqual(node2Accessor->getDistanceFromRoot(), 1uz);
		});

		suite.addTest("Bidirectional unlink (operator/)", [&] {
			auto node1 = NetworkPtr::makeRoot("Node1");
			auto node2 = NetworkPtr::make("Node2");
			node1 & node2;

			node1 / node2;

			auto node2Accessor = node2->sharedAccess();
			suite.expectEqual(node2Accessor->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
		});
	}};
}

export module CppUtils.UnitTests.Container.NetworkPtr;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Container::NetworkPtr
{
	inline auto _ = TestSuite{"Container/NetworkPtr", {"Logger"}, [](auto& suite) {
		using Logger = CppUtils::Logger<"CppUtils">;
		using NetworkPtr = CppUtils::Container::NetworkPtr<DummyObject>;
		using StringNetworkPtr = CppUtils::Container::NetworkPtr<std::string>;

		suite.addTest("Create root", [&] {
			auto _ = NetworkPtr::makeRoot("Root");
		});

		suite.addTest("Create node", [&] {
			auto _ = NetworkPtr::make("Node");
		});

		suite.addTest("Read value", [&] {
			auto node = StringNetworkPtr::make("Node");
			{
				auto accessor = node->sharedAccess();
				suite.expect(accessor->value == "Node");
			}
		});

		suite.addTest("Write value", [&] {
			auto node = StringNetworkPtr::make("Node");
			{
				auto accessor = node->uniqueAccess();
				accessor->value = "Changed";
			}
			{
				auto accessor = node->sharedAccess();
				suite.expect(accessor->value == "Changed");
			}
		});

		suite.addTest("Create branch", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				rootRef.attachChild(branch, branchRef);
			}
			Logger::print("Persistance de Branch\n");
		});

		suite.addTest("Create leaf", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
					auto& rootRef = std::get<0>(accessor.values);
					auto& branchRef = std::get<1>(accessor.values);
					rootRef.attachChild(branch, branchRef);
				}
				{
					auto leaf = NetworkPtr::make("Leaf", 2uz);
					auto accessor = CppUtils::Thread::MultipleAccessor{*branch, *leaf};
					auto& branchRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					branchRef.attachChild(leaf, leafRef);
				}
				Logger::print("Persistance de Leaf\n");
			}
			Logger::print("Persistance de Branch\n");
		});

		suite.addTest("Cut branch", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			{
				auto branch = NetworkPtr::make("Branch", 1uz);
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
					auto& rootRef = std::get<0>(accessor.values);
					auto& branchRef = std::get<1>(accessor.values);
					rootRef.attachChild(branch, branchRef);
				}
				{
					auto leaf = NetworkPtr::make("Leaf", 2uz);
					auto accessor = CppUtils::Thread::MultipleAccessor{*branch, *leaf};
					auto& branchRef = std::get<0>(accessor.values);
					auto& leafRef = std::get<1>(accessor.values);
					branchRef.attachChild(leaf, leafRef);
				}
				Logger::print("Persistance de Leaf\n");
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				rootRef.detachChild(branch, branchRef);
			}
			Logger::print("Non-persistance de Branch\n");
		});

		suite.addTest("Bilateral attachment", [&] {
			auto root = NetworkPtr::makeRoot("Root");
			auto branch = CppUtils::Container::SafeShared<NetworkPtr>{};
			{
				branch = NetworkPtr::make("Branch", 1uz);
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				rootRef.attachChild(branch, branchRef);
			}
			Logger::print("Persistance de Branch\n");
			{
				auto accessor = CppUtils::Thread::MultipleAccessor{*root, *branch};
				auto& rootRef = std::get<0>(accessor.values);
				auto& branchRef = std::get<1>(accessor.values);
				Logger::print("Création d'une boucle\n");
				branchRef.attachChild(root, rootRef);
			}
			Logger::print("Libération de la boucle\n");
		});
	}};
}

export module CppUtils.UnitTests.Container.MeshNetwork;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Container::MeshNetwork
{
	inline auto _ = TestSuite{"Container/MeshNetwork", {"Container/NetworkPtr"}, [](auto& suite) {
		using namespace std::literals;
		using Logger = CppUtils::Logger<"CppUtils">;
		using StringMeshNodePtr = CppUtils::Container::MeshNodePtr<std::string, std::string>;
		using Node = StringMeshNodePtr::NetworkPtr::Value;

		suite.addTest("Initialization", [&] {
			auto _ = StringMeshNodePtr::make("banana");
		});

		suite.addTest("Access value", [&] {
			auto apple = StringMeshNodePtr::make("apple");
			auto accessor = apple->sharedAccess();
			const auto& value = accessor->value.value;
			Logger::print("{}\n", value);
			suite.expectEqual(value, "apple");
		});

		suite.addTest("Copy reference", [&] {
			StringMeshNodePtr appleRef;
			{
				auto apple = StringMeshNodePtr::make("apple");
				appleRef = apple;
			}
			auto accessor = appleRef->sharedAccess();
			const auto& value = accessor->value.value;
			Logger::print("{}\n", value);
			suite.expectEqual(value, "apple");
		});

		suite.addTest("Attach child", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			{
				auto apple = StringMeshNodePtr::make("apple");
				Node::attach(fruit.get(), "Elements", apple.get());
			}

			auto fruitAccessor = fruit->sharedAccess();
			const auto& fruitBranches = fruitAccessor->value.branches;
			suite.expectEqual(std::size(fruitBranches), 1uz);
			const auto& fruits = fruitBranches.at("Elements");
			suite.expectEqual(std::size(fruits), 1uz);
			{
				auto apple = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
				auto appleAccessor = apple->sharedAccess();
				const auto& value = appleAccessor->value.value;
				Logger::print("{}\n", value);
				suite.expectEqual(value, "apple");
			}
		});

		suite.addTest("Operator==: Equal nodes", [&] {
			auto node1 = StringMeshNodePtr::make("test");
			auto node2 = node1;
			suite.expectEqual(node1, node2);
		});

		suite.addTest("Operator==: Unequal nodes", [&] {
			auto node1 = StringMeshNodePtr::make("test1");
			auto node2 = StringMeshNodePtr::make("test2");
			suite.expect(node1 != node2);
		});

		suite.addTest("Operator==: Assigned nodes", [&] {
			auto node1 = StringMeshNodePtr::make("test");
			auto node2 = StringMeshNodePtr{};
			node2 = node1;
			suite.expectEqual(node1, node2);
		});

		suite.addTest("Operator==: Node and null", [&] {
			auto node1 = StringMeshNodePtr::make("test");
			auto node2 = StringMeshNodePtr{};
			suite.expect(node1 != node2);
		});

		suite.addTest("Detach child", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");
			auto banana = StringMeshNodePtr::make("banana");
			Node::attach(fruit.get(), "Elements", apple.get());
			Node::attach(fruit.get(), "Elements", banana.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 2uz);
				{
					auto apple = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
					auto appleAccessor = apple->sharedAccess();
					const auto& value = appleAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "apple");
				}
				{
					auto banana = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[1]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements", apple.get());

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				{
					auto banana = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements", banana.get());

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 0uz);
			}
		});

		suite.addTest("Detach children", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");
			auto banana = StringMeshNodePtr::make("banana");
			Node::attach(fruit.get(), "Elements", apple.get());
			Node::attach(fruit.get(), "Elements", banana.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 2uz);
				{
					auto apple = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
					auto appleAccessor = apple->sharedAccess();
					const auto& value = appleAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "apple");
				}
				{
					auto banana = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[1]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements");

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 0uz);
			}
		});

		suite.addTest("Detach child with multiple links", [&] {
			auto elements = StringMeshNodePtr::makeRoot("elements");
			auto orange = StringMeshNodePtr::make("orange");

			Node::attach(elements.get(), "Color", orange.get());
			Node::attach(elements.get(), "Fruit", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("Color"), 1uz);
				suite.expectEqual(branches.count("Fruit"), 1uz);
				suite.expectEqual(std::size(branches.at("Color")), 1uz);
				suite.expectEqual(std::size(branches.at("Fruit")), 1uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), 1uz);
			}

			Node::detach(elements.get(), "Color", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("Color"), 0uz);
				suite.expectEqual(branches.count("Fruit"), 1uz);
				suite.expectEqual(std::size(branches.at("Fruit")), 1uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), 1uz);
			}

			Node::detach(elements.get(), "Fruit", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("Color"), 0uz);
				suite.expectEqual(branches.count("Fruit"), 0uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
			}
		});

		suite.addTest("Bidirectional link", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");
			Node::attach("Categories", fruit.get(), "Elements", apple.get());
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				auto firstFruit = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
				auto appleAccessor = firstFruit->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
			{
				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				const auto& appleCategories = appleBranches.at("Categories");
				suite.expect(std::size(appleCategories) == 1);
				auto firstCategory = StringMeshNodePtr::NetworkPtr::SharedPtr{appleCategories[0]};
				auto fruitAccessor = firstCategory->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
		});

		suite.addTest("Bidirectional link (reverse order)", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");
			Node::attach("Elements", apple.get(), "Categories", fruit.get());
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				auto firstFruit = StringMeshNodePtr::NetworkPtr::SharedPtr{fruits[0]};
				auto appleAccessor = firstFruit->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
			{
				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				const auto& appleCategories = appleBranches.at("Categories");
				suite.expect(std::size(appleCategories) == 1);
				auto firstCategory = StringMeshNodePtr::NetworkPtr::SharedPtr{appleCategories[0]};
				auto fruitAccessor = firstCategory->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
		});

		suite.addTest("Many", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto banana = StringMeshNodePtr::make("banana");
			auto orangeFruit = StringMeshNodePtr::make("orange");
			auto lemon = StringMeshNodePtr::make("lemon");

			Node::attach("Categories", fruit.get(), "Elements", banana.get());
			Node::attach("Categories", fruit.get(), "Elements", orangeFruit.get());
			Node::attach("Categories", fruit.get(), "Elements", lemon.get());

			auto color = StringMeshNodePtr::makeRoot("color");
			auto orangeColor = StringMeshNodePtr::make("orange");
			auto yellow = StringMeshNodePtr::make("yellow");

			Node::attach("Categories", color.get(), "Elements", orangeColor.get());
			Node::attach("Categories", color.get(), "Elements", yellow.get());

			Node::attach("Elements", banana.get(), "Colors", yellow.get());
			Node::attach("Elements", orangeFruit.get(), "Colors", orangeColor.get());
			Node::attach("Elements", lemon.get(), "Colors", yellow.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				for (const auto& weakFruit : fruitBranches.at("Elements"))
				{
					auto fruit = StringMeshNodePtr::NetworkPtr::SharedPtr{weakFruit};
					auto fruitAccessor = fruit->sharedAccess();
					const auto& fruitBranches = fruitAccessor->value.branches;

					const auto& fruitCategories = fruitBranches.at("Categories");
					suite.expect(std::size(fruitCategories) == 1);
					auto fruitCategory = StringMeshNodePtr::NetworkPtr::SharedPtr{fruitCategories[0]};
					auto fruitCategoryAccessor = fruitCategory->sharedAccess();
					suite.expectEqual(fruitCategoryAccessor->value.value, "fruit");

					const auto& colors = fruitBranches.at("Colors");
					suite.expect(std::size(colors) == 1);
					auto color = StringMeshNodePtr::NetworkPtr::SharedPtr{colors[0]};
					auto colorAccessor = color->sharedAccess();

					Logger::print("{} is a {} {}\n", fruitAccessor->value.value, colorAccessor->value.value, fruitCategoryAccessor->value.value);
				}
			}
		});

		suite.addTest("Attach (operator>>)", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");

			root["Branch"] >> child;

			auto rootAccessor = root->sharedAccess();
			const auto& branches = rootAccessor->value.branches;
			suite.expectEqual(std::size(branches), 1uz);
			const auto& children = branches.at("Branch");
			suite.expectEqual(std::size(children), 1uz);
			auto childAccessor = child->sharedAccess();
			suite.expectEqual(childAccessor->getDistanceFromRoot(), 1uz);
		});

		suite.addTest("Chaining (operator>>)", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");

			root["Branch1"] >> child1["Branch2"] >> child2;

			auto rootAccessor = root->sharedAccess();
			const auto& rootBranches = rootAccessor->value.branches;
			suite.expectEqual(std::size(rootBranches), 1uz);
			auto child1Accessor = child1->sharedAccess();
			const auto& child1Branches = child1Accessor->value.branches;
			suite.expectEqual(std::size(child1Branches), 1uz);
		});

		suite.addTest("Unlink (operator-)", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");

			root["Branch"] >> child;
			root["Branch"] - child;

			auto rootAccessor = root->sharedAccess();
			const auto& branches = rootAccessor->value.branches;
			suite.expect(std::empty(branches));
		});

		suite.addTest("Bidirectional link (operator&)", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");

			fruit["Elements"] & apple["Category"];

			suite.expect(fruit.contains("Elements"));
			suite.expectEqual(std::size(fruit["Elements"]), 1uz);
			suite.expectEqual(fruit["Elements"][0].value().getValue().value(), "apple");

			suite.expect(apple.contains("Category"));
			suite.expectEqual(std::size(apple["Category"]), 1uz);
			suite.expectEqual(apple["Category"][0].value().getValue().value(), "fruit");
		});

		suite.addTest("Bidirectional unlink (operator/)", [&] {
			auto fruit = StringMeshNodePtr::makeRoot("fruit");
			auto apple = StringMeshNodePtr::make("apple");
			auto banana = StringMeshNodePtr::make("banana");
			fruit["Elements"] & apple["Category"];
			fruit["Elements"] & banana["Category"];

			fruit["Elements"] / apple["Category"];

			suite.expect(fruit.contains("Elements"));
			suite.expectEqual(std::size(fruit["Elements"]), 1uz);
			suite.expect(not apple.contains("Category"));

			fruit["Elements"] / banana["Category"];

			suite.expect(not fruit.contains("Elements"));
			suite.expect(not banana.contains("Category"));
		});

		suite.addTest("Get value", [&] {
			auto node = StringMeshNodePtr::make("value");

			auto expectedValue = node.getValue();

			suite.expect(expectedValue.has_value());
			suite.expectEqual(expectedValue.value(), "value");
		});

		suite.addTest("Get value: Invalid node", [&] {
			auto emptyNode = StringMeshNodePtr{};

			auto unexpectedValue = emptyNode.getValue();

			suite.expect(not unexpectedValue.has_value());
			suite.expectEqual(unexpectedValue.error(), "Invalid MeshNodePtr"sv);
		});

		suite.addTest("Set value", [&] {
			auto node = StringMeshNodePtr::make("initial");

			node.setValue("updated");

			auto expectedValue = node.getValue();
			suite.expect(expectedValue.has_value());
			suite.expectEqual(expectedValue.value(), "updated");
		});

		suite.addTest("Contains", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");
			root["Branch"] >> child;

			suite.expect(root.contains("Branch"));
			suite.expect(not root.contains("NonExistentBranch"));
		});

		suite.addTest("Branch size", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");

			suite.expectEqual(std::size(root["Branch"]), 0uz);
			suite.expect(std::empty(root["Branch"]));

			root["Branch"] >> child1;
			suite.expectEqual(std::size(root["Branch"]), 1uz);
			suite.expect(not std::empty(root["Branch"]));

			root["Branch"] >> child2;
			suite.expectEqual(std::size(root["Branch"]), 2uz);

			root["Branch"] - child1;
			suite.expectEqual(std::size(root["Branch"]), 1uz);
		});

		suite.addTest("Clear branch", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");
			root["Branch"] >> child1;
			root["Branch"] >> child2;

			root["Branch"].clear();

			suite.expect(std::empty(root["Branch"]));
			suite.expect(root.contains("Branch"));
		});

		suite.addTest("Erase branch", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");
			root["Branch"] >> child;

			root["Branch"].erase();

			suite.expect(not root.contains("Branch"));
		});

		suite.addTest("Get node", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");
			root["Branch"] >> child;

			auto childExpected = root["Branch"][0];

			suite.expect(childExpected.has_value());
			suite.expectEqual(childExpected.value().getValue().value(), "child");
		});

		suite.addTest("Get node: Newly created branch", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");

			auto invalidKeyExpected = root["Branch"][0];

			suite.expect(not invalidKeyExpected.has_value());
			suite.expectEqual(invalidKeyExpected.error(), "Branch index out of bounds"sv);
		});

		suite.addTest("Get node: Invalid index", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");
			root["Branch"] >> child;

			auto invalidIndexExpected = root["Branch"][1];

			suite.expect(not invalidIndexExpected.has_value());
			suite.expectEqual(invalidIndexExpected.error(), "Branch index out of bounds"sv);
		});

		suite.addTest("Get node: Invalid node", [&] {
			auto emptyNode = StringMeshNodePtr{};

			suite.template expectThrow<std::runtime_error>([&] {
				auto _ = emptyNode["Branch"];
			});
		});

		suite.addTest("Get nodes", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");
			root["Branch"] >> child1;
			root["Branch"] >> child2;

			auto children = std::vector<StringMeshNodePtr>{};
			for (const auto& child : root["Branch"])
				children.push_back(child);

			suite.expectEqual(std::size(children), 2uz);
			suite.expectEqual(children[0].getValue().value(), "child1");
			suite.expectEqual(children[1].getValue().value(), "child2");
		});

		suite.addTest("Get nodes: Non-existent branch", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");

			auto children = std::vector<StringMeshNodePtr>{};
			for (const auto& child : root["NonExistentBranch"])
				children.push_back(child);

			suite.expect(std::empty(children));
		});

		suite.addTest("Get nodes: Invalid node", [&] {
			auto emptyNode = StringMeshNodePtr{};

			suite.template expectThrow<std::runtime_error>([&] {
				auto _ = emptyNode["Branch"];
			});
		});

		suite.addTest("at()", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child = StringMeshNodePtr::make("child");
			root["Branch"] >> child;
			const auto& constRoot = root;

			const auto children = constRoot.at("Branch");

			suite.expectEqual(std::size(children), 1uz);
			suite.expectEqual(children[0]->getValue().value(), "child");
		});

		suite.addTest("at(): Non-existent branch", [&] {
			const auto root = StringMeshNodePtr::makeRoot("root");

			suite.template expectThrow<std::out_of_range>([&] {
				auto _ = root.at("NonExistentBranch");
			});
		});

		suite.addTest("at(): Invalid node", [&] {
			const auto invalidNode = StringMeshNodePtr{};
			suite.template expectThrow<std::runtime_error>([&] {
				auto _ = invalidNode.at("Branch");
			});
		});

		suite.addTest("Get first node", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");
			root["Branch"] >> child1;
			root["Branch"] >> child2;

			auto childExpected = root["Branch"].front();

			suite.expect(childExpected.has_value());
			suite.expectEqual(childExpected.value().getValue().value(), "child1");
		});

		suite.addTest("Get last node", [&] {
			auto root = StringMeshNodePtr::makeRoot("root");
			auto child1 = StringMeshNodePtr::make("child1");
			auto child2 = StringMeshNodePtr::make("child2");
			root["Branch"] >> child1;
			root["Branch"] >> child2;

			auto childExpected = root["Branch"].back();

			suite.expect(childExpected.has_value());
			suite.expectEqual(childExpected.value().getValue().value(), "child2");
		});
	}};
}

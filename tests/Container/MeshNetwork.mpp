export module CppUtils.UnitTests.Container.MeshNetwork;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Container::MeshNetwork
{
	inline auto _ = TestSuite{"Container/MeshNetwork", {"Container/NetworkPtr"}, [](auto& suite) {
		using Logger = CppUtils::Logger<"CppUtils">;
		using StringMeshNode = CppUtils::Container::MeshNodePtr<std::string, std::string>;
		using Node = StringMeshNode::NodePtr::Value;

		suite.addTest("Initialization", [&] {
			auto _ = StringMeshNode::make("banana");
		});

		suite.addTest("Access value", [&] {
			auto apple = StringMeshNode::make("apple");
			auto accessor = apple->sharedAccess();
			const auto& value = accessor->value.value;
			Logger::print("{}\n", value);
			suite.expectEqual(value, "apple");
		});

		suite.addTest("Copy reference", [&] {
			auto appleRef = std::optional<StringMeshNode>{};
			{
				auto apple = StringMeshNode::make("apple");
				appleRef = apple;
			}
			auto accessor = (*appleRef)->sharedAccess();
			const auto& value = accessor->value.value;
			Logger::print("{}\n", value);
			suite.expectEqual(value, "apple");
		});

		suite.addTest("Attach child", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			{
				auto apple = StringMeshNode::make("apple");
				Node::attach(fruit.get(), "Elements", apple.get());
			}

			auto fruitAccessor = fruit->sharedAccess();
			const auto& fruitBranches = fruitAccessor->value.branches;
			suite.expectEqual(std::size(fruitBranches), 1uz);
			const auto& fruits = fruitBranches.at("Elements");
			suite.expectEqual(std::size(fruits), 1uz);
			{
				auto apple = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
				auto appleAccessor = apple->sharedAccess();
				const auto& value = appleAccessor->value.value;
				Logger::print("{}\n", value);
				suite.expectEqual(value, "apple");
			}
		});

		suite.addTest("Detach child", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");
			auto banana = StringMeshNode::make("banana");
			Node::attach(fruit.get(), "Elements", apple.get());
			Node::attach(fruit.get(), "Elements", banana.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 2uz);
				{
					auto apple = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
					auto appleAccessor = apple->sharedAccess();
					const auto& value = appleAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "apple");
				}
				{
					auto banana = StringMeshNode::NodePtr::SharedPtr{fruits[1]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements", apple.get());

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				{
					auto banana = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements", banana.get());

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 0uz);
			}
		});

		suite.addTest("Detach children", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");
			auto banana = StringMeshNode::make("banana");
			Node::attach(fruit.get(), "Elements", apple.get());
			Node::attach(fruit.get(), "Elements", banana.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 2uz);
				{
					auto apple = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
					auto appleAccessor = apple->sharedAccess();
					const auto& value = appleAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "apple");
				}
				{
					auto banana = StringMeshNode::NodePtr::SharedPtr{fruits[1]};
					auto bananaAccessor = banana->sharedAccess();
					const auto& value = bananaAccessor->value.value;
					Logger::print("{}\n", value);
					suite.expectEqual(value, "banana");
				}
			}

			{
				Node::detach(fruit.get(), "Elements");

				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 0uz);
			}
		});

		suite.addTest("Detach child with multiple links", [&] {
			auto elements = StringMeshNode::makeRoot("elements");
			auto orange = StringMeshNode::make("orange");

			Node::attach(elements.get(), "color", orange.get());
			Node::attach(elements.get(), "fruit", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("color"), 1uz);
				suite.expectEqual(branches.count("fruit"), 1uz);
				suite.expectEqual(std::size(branches.at("color")), 1uz);
				suite.expectEqual(std::size(branches.at("fruit")), 1uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), 1uz);
			}

			Node::detach(elements.get(), "color", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("color"), 0uz);
				suite.expectEqual(branches.count("fruit"), 1uz);
				suite.expectEqual(std::size(branches.at("fruit")), 1uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), 1uz);
			}

			Node::detach(elements.get(), "fruit", orange.get());
			{
				auto elementAccessor = elements->sharedAccess();
				const auto& branches = elementAccessor->value.branches;
				suite.expectEqual(branches.count("color"), 0uz);
				suite.expectEqual(branches.count("fruit"), 0uz);
				suite.expectEqual(orange->sharedAccess()->getDistanceFromRoot(), std::numeric_limits<std::size_t>::max());
			}
		});

		suite.addTest("Bilateral attachment", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");
			Node::attach("Categories", fruit.get(), "Elements", apple.get());
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				auto firstFruit = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
				auto appleAccessor = firstFruit->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
			{
				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				const auto& appleCategories = appleBranches.at("Categories");
				suite.expect(std::size(appleCategories) == 1);
				auto firstCategory = StringMeshNode::NodePtr::SharedPtr{appleCategories[0]};
				auto fruitAccessor = firstCategory->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
		});

		suite.addTest("Bilateral attachment (reverse order)", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");
			Node::attach("Elements", apple.get(), "Categories", fruit.get());
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				const auto& fruits = fruitBranches.at("Elements");
				suite.expectEqual(std::size(fruits), 1uz);
				auto firstFruit = StringMeshNode::NodePtr::SharedPtr{fruits[0]};
				auto appleAccessor = firstFruit->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
			{
				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				const auto& appleCategories = appleBranches.at("Categories");
				suite.expect(std::size(appleCategories) == 1);
				auto firstCategory = StringMeshNode::NodePtr::SharedPtr{appleCategories[0]};
				auto fruitAccessor = firstCategory->sharedAccess();
				const auto& appleName = appleAccessor->value.value;
				const auto& fruitName = fruitAccessor->value.value;
				Logger::print("{} is a {}\n", appleName, fruitName);
				suite.expectEqual(appleName, "apple");
				suite.expectEqual(fruitName, "fruit");
			}
		});

		suite.addTest("Many", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto banana = StringMeshNode::make("banana");
			auto orangeFruit = StringMeshNode::make("orange");
			auto lemon = StringMeshNode::make("lemon");

			Node::attach("Categories", fruit.get(), "Elements", banana.get());
			Node::attach("Categories", fruit.get(), "Elements", orangeFruit.get());
			Node::attach("Categories", fruit.get(), "Elements", lemon.get());

			auto color = StringMeshNode::makeRoot("color");
			auto orangeColor = StringMeshNode::make("orange");
			auto yellow = StringMeshNode::make("yellow");

			Node::attach("Categories", color.get(), "Elements", orangeColor.get());
			Node::attach("Categories", color.get(), "Elements", yellow.get());

			Node::attach("Elements", banana.get(), "Colors", yellow.get());
			Node::attach("Elements", orangeFruit.get(), "Colors", orangeColor.get());
			Node::attach("Elements", lemon.get(), "Colors", yellow.get());

			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				for (const auto& weakFruit : fruitBranches.at("Elements"))
				{
					auto fruit = StringMeshNode::NodePtr::SharedPtr{weakFruit};
					auto fruitAccessor = fruit->sharedAccess();
					const auto& fruitBranches = fruitAccessor->value.branches;

					const auto& fruitCategories = fruitBranches.at("Categories");
					suite.expect(std::size(fruitCategories) == 1);
					auto fruitCategory = StringMeshNode::NodePtr::SharedPtr{fruitCategories[0]};
					auto fruitCategoryAccessor = fruitCategory->sharedAccess();
					suite.expectEqual(fruitCategoryAccessor->value.value, "fruit");

					const auto& colors = fruitBranches.at("Colors");
					suite.expect(std::size(colors) == 1);
					auto color = StringMeshNode::NodePtr::SharedPtr{colors[0]};
					auto colorAccessor = color->sharedAccess();

					Logger::print("{} is a {} {}\n", fruitAccessor->value.value, colorAccessor->value.value, fruitCategoryAccessor->value.value);
				}
			}
		});

		suite.addTest("Attach (operator>>)", [&] {
			auto root = StringMeshNode::makeRoot("root");
			auto child = StringMeshNode::make("child");

			root["branch"] >> child;

			auto rootAccessor = root->sharedAccess();
			const auto& branches = rootAccessor->value.branches;
			suite.expectEqual(std::size(branches), 1uz);
			const auto& children = branches.at("branch");
			suite.expectEqual(std::size(children), 1uz);
			auto childAccessor = child->sharedAccess();
			suite.expectEqual(childAccessor->getDistanceFromRoot(), 1uz);
		});

		suite.addTest("Chaining (operator>>)", [&] {
			auto root = StringMeshNode::makeRoot("root");
			auto child1 = StringMeshNode::make("child1");
			auto child2 = StringMeshNode::make("child2");

			root["branch1"] >> child1["branch2"] >> child2;

			auto rootAccessor = root->sharedAccess();
			const auto& rootBranches = rootAccessor->value.branches;
			suite.expectEqual(std::size(rootBranches), 1uz);
			auto child1Accessor = child1->sharedAccess();
			const auto& child1Branches = child1Accessor->value.branches;
			suite.expectEqual(std::size(child1Branches), 1uz);
		});

		suite.addTest("Unlink (operator-)", [&] {
			auto root = StringMeshNode::makeRoot("root");
			auto child = StringMeshNode::make("child");

			root["branch"] >> child;
			root["branch"] - child;

			auto rootAccessor = root->sharedAccess();
			const auto& branches = rootAccessor->value.branches;
			suite.expect(std::empty(branches));
		});

		suite.addTest("Bidirectional link (operator&)", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");

			fruit["elements"] & apple["category"];
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expectEqual(std::size(fruitBranches), 1uz);
				suite.expectEqual(std::size(fruitBranches.at("category")), 1uz);

				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				suite.expectEqual(std::size(appleBranches), 1uz);
				suite.expectEqual(std::size(appleBranches.at("elements")), 1uz);
			}
		});

		suite.addTest("Bidirectional unlink (operator/)", [&] {
			auto fruit = StringMeshNode::makeRoot("fruit");
			auto apple = StringMeshNode::make("apple");

			fruit["elements"] & apple["category"];
			fruit["elements"] / apple["category"];
			{
				auto fruitAccessor = fruit->sharedAccess();
				const auto& fruitBranches = fruitAccessor->value.branches;
				suite.expect(std::empty(fruitBranches));
				auto appleAccessor = apple->sharedAccess();
				const auto& appleBranches = appleAccessor->value.branches;
				suite.expect(std::empty(appleBranches));
			}
		});
	}};
}

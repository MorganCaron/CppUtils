export module CppUtils.UnitTests.Terminal.Canvas;

import std;
import CppUtils;

export namespace CppUtils::UnitTest::Terminal::Canvas
{
	inline auto _ = TestSuite{"Terminal/Canvas", {"UnitTest", "Thread/Scheduler", "String/Encoding"}, [](auto& suite) {
		using namespace std::literals;
		using namespace std::chrono_literals;

		suite.addTest("Size", [&] {
			{
				auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{10, 5}};
				canvas.fill('/');
				canvas.print();
				std::this_thread::sleep_for(300ms);
			}
			{
				auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{16, 9}};
				canvas.fill('.');
				canvas.print();
				std::this_thread::sleep_for(300ms);
			}
			{
				auto canvas = CppUtils::Terminal::Canvas{};
				canvas.fill('#');
				canvas.print();
				std::this_thread::sleep_for(300ms);
			}
		});

		suite.addTest("Fill", [&] {
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{10, 5}};
			const auto chars = "-\\|/"sv;
			for (auto i = 0uz; i < 5; ++i)
				for (auto c : chars)
				{
					std::this_thread::sleep_for(50ms);
					canvas.fill(c);
					canvas.print();
				}
		});

		suite.addTest("Spinner", [&] {
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{1, 1}};
			const auto frames = std::array{
				CppUtils::Terminal::FixedAreaBuffer<1, 1>{'-'},
				CppUtils::Terminal::FixedAreaBuffer<1, 1>{'\\'},
				CppUtils::Terminal::FixedAreaBuffer<1, 1>{'|'},
				CppUtils::Terminal::FixedAreaBuffer<1, 1>{'/'}};
			canvas.addWidget(std::make_unique<CppUtils::Terminal::Spinner<1, 1, 4>>(frames));
			auto scheduler = CppUtils::Thread::Scheduler{};
			scheduler.schedule([&canvas]() mutable {
				canvas.close();
			}, 1s);
			canvas.wait();
		});

		suite.addTest("Print text", [&] {
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{10, 5}};
			canvas.fill('.');
			canvas.printText(CppUtils::Container::Size2{1, 1}, "Hello World!");
			canvas.print();

			suite.expectEqual(canvas.toString(), "..........\n.Hello Wor\nld!.......\n..........\n..........\n"sv);
		});

		suite.addTest("Print Unicode", [&] {
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{15, 5}};
			canvas.fill('-');
			canvas.printText(CppUtils::Container::Size2{1, 1}, "ðŸ˜Š");
			canvas.print();

			suite.expectEqual(canvas.toString(), "---------------\n-ðŸ˜Š------------\n---------------\n---------------\n---------------\n"sv);
		});

		suite.addTest("Progress bar", [&] {
			const auto terminalWidth = CppUtils::Terminal::getTerminalSize().width();
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{terminalWidth, 1}};
			auto& progressBar = canvas.addWidget(std::make_unique<CppUtils::Terminal::ProgressBar>("Progress bar"));

			auto scheduler = CppUtils::Thread::Scheduler{};
			scheduler.schedule([&canvas]() mutable {
				canvas.close();
			}, 500ms);

			for (auto i = 0.f; i <= 100.f; i += 1.f)
			{
				progressBar.setPercent(i);
				std::this_thread::sleep_for(5ms);
			}

			canvas.wait();
		});

		suite.addTest("Multiple Progress Bars", [&] {
			const auto terminalWidth = CppUtils::Terminal::getTerminalSize().width();
			auto canvas = CppUtils::Terminal::Canvas{CppUtils::Container::Size2{terminalWidth, 3}};
			auto& layout = canvas.addWidget(std::make_unique<CppUtils::Terminal::Layout>());

			auto& bar1 = layout.addWidget(std::make_unique<CppUtils::Terminal::ProgressBar>("Bar 1"));
			auto& bar2 = layout.addWidget(std::make_unique<CppUtils::Terminal::ProgressBar>("Bar 2"));
			auto& bar3 = layout.addWidget(std::make_unique<CppUtils::Terminal::ProgressBar>("Bar 3"));

			auto scheduler = CppUtils::Thread::Scheduler{};
			scheduler.schedule([&canvas]() mutable {
				canvas.close();
			}, 1'000ms);

			for (auto i = 0.f; i <= 100.f; i += 1.f)
			{
				bar1.setPercent(i);
				bar2.setPercent(CppUtils::Math::Easing::inQuad(i / 100.f) * 100.f);
				bar3.setPercent(CppUtils::Math::Easing::outCubic(i / 100.f) * 100.f);
				std::this_thread::sleep_for(10ms);
			}

			canvas.wait();
		});

		suite.addTest("Bouncing ball", [&] {
			const auto terminalSize = CppUtils::Terminal::getTerminalSize();
			auto canvasSize = terminalSize;
			canvasSize.height() = std::min(canvasSize.width() * 1 / 3, terminalSize.height() - 2);
			auto canvas = CppUtils::Terminal::Canvas{canvasSize};
			auto ballPosition = CppUtils::Container::Vec2<float>{};
			auto ballVelocity = CppUtils::Container::Vec2<float>{1.f, 1.f};
			auto charPosition = CppUtils::Container::Size2{};
			const auto collisionBox = canvasSize - CppUtils::Container::Size2{1, 0};

			for (auto i = 0uz; i <= 500uz; ++i)
			{
				canvas.printText(charPosition, ".");
				auto previousBallPosition = ballPosition;
				ballPosition += ballVelocity; // Energie cinÃ©tique
				ballVelocity *= .997f; // Frottements de l'air
				ballVelocity.y() += .05f; // GravitÃ©

				for (const auto axis : {0uz, 1uz})
					if (const auto limit = static_cast<float>(collisionBox[axis]); ballPosition[axis] < 0.f or ballPosition[axis] > limit)
					{
						const auto total = ballPosition[axis] - previousBallPosition[axis];
						const auto over = ballPosition[axis] - std::clamp(ballPosition[axis], 0.f, limit);
						const auto ratio = 1.f - over / total;
						ballPosition = previousBallPosition + ballVelocity * ratio;
						previousBallPosition = ballPosition - ballVelocity * (1.0f - ratio);
						ballVelocity[axis] = -ballVelocity[axis];
						ballPosition += ballVelocity * (1.f - ratio);
						ballVelocity[axis] *= .75f; // Friction
						if (std::abs(ballVelocity[axis]) < .1f)
							ballVelocity[axis] = 0.f; // Immobilisation par frottements
					}

				charPosition.x() = static_cast<std::size_t>(std::roundf(ballPosition.x()));
				charPosition.y() = static_cast<std::size_t>(std::roundf(ballPosition.y()));
				canvas.printText(charPosition, "âš½");

				canvas.print();
				std::this_thread::sleep_for(5ms);
			}
		});
	}};
}

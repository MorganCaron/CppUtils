export module CppUtils.Terminal.Area:DynamicAreaBuffer;

import std;
import CppUtils.Container.Size;
import CppUtils.Terminal.AreaBuffer;
import CppUtils.Terminal.CharAttributes;

export namespace CppUtils::Terminal
{
	class DynamicAreaBuffer: public AreaBuffer
	{
	public:
		using Line = std::vector<CharAttributes>;
		using Buffer = std::vector<Line>;

		inline DynamicAreaBuffer(const Container::Size2& size, CharAttributes defaultCharAttributes = {}):
			DynamicAreaBuffer{size, Buffer(size.height(), Line(size.width(), defaultCharAttributes))}
		{}

		inline DynamicAreaBuffer(const Container::Size2& size, char defaultChar):
			DynamicAreaBuffer{size, CharAttributes{defaultChar}}
		{}

		inline DynamicAreaBuffer(const Container::Size2& size, Buffer&& buffer):
			m_size{size},
			m_buffer{std::move(buffer)}
		{}

		inline auto setSize(const Container::Size2& size) noexcept -> void
		{
			auto lock = std::unique_lock{m_mutex};
			m_size = size;
			m_buffer = Buffer(m_size.height(), Line(m_size.width()));
		}

		[[nodiscard]] inline auto getSize() const noexcept -> Container::Size2 override
		{
			auto lock = std::unique_lock{m_mutex};
			return m_size;
		}

		[[nodiscard]] auto getChar(const Container::Size2& position) const noexcept -> const CharAttributes& final
		{
			auto lock = std::unique_lock{m_mutex};
			return m_buffer[position.y()][position.x()];
		}

		auto setChar(const Container::Size2& position, const CharAttributes& c) noexcept -> void final
		{
			auto lock = std::unique_lock{m_mutex};
			if (position.x() >= m_size.width() or position.y() >= m_size.height())
				return;

			if (position.x() + 1 == m_size.width() and c.displayWidth == 2)
				return;

			if (auto& oldChar = m_buffer[position.y()][position.x()];
				oldChar.displayWidth == 2)
			{
				if (position.x() + 1 < m_size.width())
					if (auto& nextChar = m_buffer[position.y()][position.x() + 1];
						nextChar.displayWidth == 0)
						nextChar = CharAttributes{' '};
			}
			else if (oldChar.displayWidth == 0)
			{
				if (position.x() > 0)
					if (auto& previousChar = m_buffer[position.y()][position.x() - 1];
						previousChar.displayWidth == 2)
						previousChar = CharAttributes{' '};
			}

			m_buffer[position.y()][position.x()] = c;
		}

		[[nodiscard]] inline auto getBuffer() const noexcept -> const auto&
		{
			return m_buffer;
		}

	private:
		mutable std::mutex m_mutex;
		Container::Size2 m_size;
		Buffer m_buffer;
	};
}

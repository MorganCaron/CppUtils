module;

#include <stdio.h>

export module CppUtils.Terminal.Canvas;

import std;
import CppUtils.Container.Size;
import CppUtils.Terminal.Utility;
import CppUtils.String.Encoding;
import CppUtils.Terminal.Size;
import CppUtils.Terminal.Cursor;
import CppUtils.Terminal.Area;
import CppUtils.Terminal.TextStyle;
import CppUtils.Terminal.TextColor;
import CppUtils.Terminal.BackgroundColor;

export namespace CppUtils::Terminal
{
	class Canvas final: public Area
	{
		using Area::draw;

	public:
		inline Canvas(const Container::Size2& size = getTerminalSize(), const std::optional<Viewport>& optionalViewport = std::nullopt):
			Area{size, optionalViewport.value_or(Viewport{size, {0, 0}})},
			m_previousBuffer{size}
		{
			m_widgetManager.eventDispatcher.subscribe<"RequestUpdate">([this] {
				print();
			});
			setWidgetManager(m_widgetManager);
			setConsoleOutputUTF8();
			enableAnsi();
		}

		inline auto applyDifferences() noexcept -> void
		{
			using namespace std::literals;
			auto terminalSize = getTerminalSize();
			auto stringBuffer = ""s;
			auto needFlush = false;
			auto lastAttributes = CharAttributes{};
			m_viewport.forEach([&](const auto& position) noexcept {
				const auto& currentChar = getChar(position);
				const auto& previousChar = m_previousBuffer.getChar(position);

				auto needUpdateText = currentChar.character != previousChar.character;
				auto needUpdateTextStyle = currentChar.textStyle != lastAttributes.textStyle;
				auto needUpdateTextColor = currentChar.textColor != lastAttributes.textColor;
				auto needUpdateBackgroundColor = currentChar.backgroundColor != lastAttributes.backgroundColor;

				if (needUpdateText or needUpdateTextStyle or needUpdateTextColor or needUpdateBackgroundColor)
				{
					if (std::empty(stringBuffer))
						setCursorPosition({position.x(), terminalSize.height() - m_viewport.getSize().height() + position.y()});
					if (needUpdateTextStyle)
					{
						stringBuffer += TextStyle::getTextStyleCode(currentChar.textStyle);
						lastAttributes.textStyle = currentChar.textStyle;
					}
					if (needUpdateTextColor)
					{
						stringBuffer += TextColor::Ansi::getTextColorCode(currentChar.textColor);
						lastAttributes.textColor = currentChar.textColor;
					}
					if (needUpdateBackgroundColor)
					{
						stringBuffer += BackgroundColor::Ansi::getBackgroundColorCode(currentChar.backgroundColor);
						lastAttributes.backgroundColor = currentChar.backgroundColor;
					}
					if (currentChar.displayWidth > 0)
						stringBuffer = String::toUtf8(currentChar.character, std::move(stringBuffer));
					m_previousBuffer.setChar(position, currentChar);
					if (not std::empty(stringBuffer) and position.x() + 1 == m_viewport.getSize().width())
						stringBuffer += '\n';
				}
				else if (not std::empty(stringBuffer))
				{
					std::fwrite(std::data(stringBuffer), sizeof(decltype(stringBuffer)::value_type), std::size(stringBuffer), stdout);
					stringBuffer.clear();
					needFlush = true;
				}
			});
			if (not std::empty(stringBuffer))
			{
				std::fwrite(std::data(stringBuffer), sizeof(decltype(stringBuffer)::value_type), std::size(stringBuffer), stdout);
				needFlush = true;
			}
			if (needFlush)
				std::fflush(stdout);
			setCursorPosition({0, getTerminalSize().height()});
		}

		inline auto print() noexcept -> void
		{
			auto lock = std::scoped_lock{m_printMutex};
			if (m_widget)
			{
				auto view = WritableAreaView{*this, m_viewport};
				m_widget->draw(view);
			}
			if (m_firstPrint)
			{
				std::print("{}", std::string(m_viewport.getSize().height(), '\n'));
				m_firstPrint = false;
			}
			applyDifferences();
		}

		inline auto wait() noexcept -> void
		{
			print();
			m_stopEvent.wait(false);
		}

		inline auto close() noexcept -> void
		{
			m_stopEvent.store(true, std::memory_order_release);
			m_stopEvent.notify_all();
		}

	private:
		std::mutex m_printMutex;
		bool m_firstPrint = true;
		std::atomic_bool m_stopEvent = false;
		DynamicAreaBuffer m_previousBuffer;
		WidgetManager m_widgetManager;
	};
}

export module CppUtils.Terminal.Area:WritableAreaView;

import std;
import :DynamicAreaBuffer;
import :Viewport;
import CppUtils.Terminal.AreaBuffer;
import CppUtils.Terminal.CharAttributes;

export namespace CppUtils::Terminal
{
	class WritableAreaView final
	{
	public:
		inline WritableAreaView(DynamicAreaBuffer& areaBuffer):
			WritableAreaView{areaBuffer, Viewport{areaBuffer.getSize()}}
		{}

		WritableAreaView(DynamicAreaBuffer& areaBuffer, Viewport viewport):
			m_areaBuffer{areaBuffer},
			m_viewport{std::move(viewport)}
		{}

		[[nodiscard]] inline auto getViewport() const noexcept -> const auto&
		{
			return m_viewport;
		}

		inline auto printText(Container::Size2 position, std::string_view text) noexcept -> void
		{
			for (auto i = 0uz; i < std::size(text);)
			{
				if (position.x() >= getViewport().getSize().width())
				{
					position.x() = 0;
					++position.y();
				}
				if (position.y() >= getViewport().getSize().height())
					break;

				auto bytesConsumed = 0uz;
				auto charAttributes = Terminal::CharAttributes{text.substr(i), bytesConsumed};
				setChar(position, charAttributes);

				if (charAttributes.displayWidth == 2 and position.x() + 1 < getViewport().getSize().width())
					setChar(Container::Size2{position.x() + 1, position.y()}, Terminal::CharAttributes{U' ', 0});
				position.x() += charAttributes.displayWidth;
				i += bytesConsumed;
			}
		}
		[[nodiscard]] inline auto getSubView(Viewport viewport) noexcept -> std::expected<WritableAreaView, std::string>
		{
			if (not m_viewport.contains(viewport))
				return std::unexpected{"New viewport is out of bounds"};
			return WritableAreaView{m_areaBuffer, viewport};
		}

		inline auto drawBuffer(const AreaBuffer& source, Container::Size2 destinationPosition, Viewport sourceViewport) noexcept -> void
		{
			const auto& sourceOrigin = sourceViewport.getPosition();
			sourceViewport.forEach([&](const auto& absoluteSourcePosition) {
				const auto offset = absoluteSourcePosition - sourceOrigin;
				setChar(destinationPosition + offset, source.getChar(absoluteSourcePosition));
			});
		}

		inline auto applyArea(const AreaBuffer& areaBuffer, Viewport viewport) noexcept -> void
		{
			const auto intersection = Viewport::intersection(m_viewport, viewport);
			if (intersection.getSize().width() == 0 or intersection.getSize().height() == 0)
				return;

			const auto offset = intersection.getPosition() - viewport.getPosition();
			const auto relativeDestinationPosition = intersection.getPosition() - m_viewport.getPosition();
			drawBuffer(areaBuffer, relativeDestinationPosition, Viewport{intersection.getSize(), offset});
		}

		inline auto applyArea(const AreaBuffer& areaBuffer) noexcept -> void
		{
			drawBuffer(areaBuffer, {0, 0}, Viewport{m_viewport.getSize()});
		}

		inline auto setChar(const Container::Size2& position, const CharAttributes& c) noexcept -> void
		{
			const auto absolutePosition = m_viewport.getPosition() + position;
			if (not m_viewport.contains(absolutePosition))
				return;
			m_areaBuffer.setChar(absolutePosition, c);
		}

		inline auto fill(const CharAttributes& c) noexcept -> void
		{
			m_viewport.forEach([this, &c](const auto& position) noexcept -> void {
				m_areaBuffer.setChar(position, c);
			});
		}

	private:
		DynamicAreaBuffer& m_areaBuffer;
		Viewport m_viewport;
	};
}

export module CppUtils.Terminal.Area:WritableAreaView;

import std;
import :DynamicAreaBuffer;
import :Viewport;
import CppUtils.Terminal.AreaBuffer;
import CppUtils.Terminal.CharAttributes;

export namespace CppUtils::Terminal
{
	class WritableAreaView final
	{
	public:
		WritableAreaView(DynamicAreaBuffer& areaBuffer, Viewport viewport):
			m_areaBuffer{areaBuffer},
			m_viewport{std::move(viewport)}
		{}

		[[nodiscard]] inline auto getViewport() const noexcept -> const auto&
		{
			return m_viewport;
		}

		inline auto printText(Container::Size2 position, std::string_view text) noexcept -> void
		{
			for (auto i = 0uz; i < std::size(text);)
			{
				if (position.x() >= getViewport().getSize().width())
				{
					position.x() = 0;
					++position.y();
				}
				if (position.y() >= getViewport().getSize().height())
					break;

				auto bytesConsumed = 0uz;
				auto charAttributes = Terminal::CharAttributes{text.substr(i), bytesConsumed};
				setChar(position, charAttributes);

				if (charAttributes.displayWidth == 2 and position.x() + 1 < getViewport().getSize().width())
					setChar(Container::Size2{position.x() + 1, position.y()}, Terminal::CharAttributes{U' ', 0});
				position.x() += charAttributes.displayWidth;
				i += bytesConsumed;
			}
		}
		[[nodiscard]] inline auto getSubView(Viewport viewport) noexcept -> std::expected<WritableAreaView, std::string>
		{
			if (not m_viewport.contains(viewport))
				return std::unexpected{"New viewport is out of bounds"};
			return WritableAreaView{m_areaBuffer, viewport};
		}

		inline auto applyArea(const AreaBuffer& areaBuffer, Viewport viewport) noexcept -> void
		{
			if (not m_viewport.contains(viewport))
				return;
			const auto& viewportPosition = viewport.getPosition();
			viewport.forEach([this, &areaBuffer, &viewportPosition](const auto& position) noexcept -> void {
				m_areaBuffer.setChar(position, areaBuffer.getChar(position - viewportPosition));
			});
		}

		inline auto applyArea(const AreaBuffer& areaBuffer) noexcept -> void
		{
			applyArea(areaBuffer, m_viewport);
		}

		inline auto setChar(const Container::Size2& position, const CharAttributes& c) noexcept -> void
		{
			const auto absolutePosition = m_viewport.getPosition() + position;
			if (not m_viewport.contains(absolutePosition))
				return;
			m_areaBuffer.setChar(absolutePosition, c);
		}

		inline auto fill(const CharAttributes& c) noexcept -> void
		{
			m_viewport.forEach([this, &c](const auto& position) noexcept -> void {
				m_areaBuffer.setChar(position, c);
			});
		}

	private:
		DynamicAreaBuffer& m_areaBuffer;
		Viewport m_viewport;
	};
}

export module CppUtils.Terminal.Area;

import std;
import CppUtils.Container.Size;
export import CppUtils.Terminal.CharAttributes;
export import :DynamicAreaBuffer;
export import :Viewport;
export import :Widget;
export import :WidgetManager;
export import :WritableAreaView;

export namespace CppUtils::Terminal
{
	class Area: public Widget, public DynamicAreaBuffer
	{
	public:
		inline Area(const Container::Size2& size, const Viewport& viewport = {{0, 0}, {0, 0}}):
			DynamicAreaBuffer{size},
			m_viewport{viewport}
		{}

		template<std::derived_from<Widget> T>
		inline auto addWidget(std::unique_ptr<T> widget) -> T&
		{
			widget->setWidgetManager(getWidgetManager());
			m_widget = std::move(widget);
			return dynamic_cast<T&>(*m_widget);
		}

		inline auto requestFullRender() noexcept -> void
		{
			m_fullRenderRequested = true;
		}

		inline auto setViewport(const Viewport& viewport) noexcept -> void
		{
			m_viewport = viewport;
			requestFullRender();
		}

		[[nodiscard]] inline auto getViewport() const noexcept -> const auto&
		{
			return m_viewport;
		}

		[[nodiscard]] inline auto getSize() const noexcept -> Container::Size2 final
		{
			return DynamicAreaBuffer::getSize();
		}

		inline auto fill(const CharAttributes& c) noexcept -> void
		{
			auto view = WritableAreaView{*this, m_viewport};
			view.fill(c);
			requestFullRender();
		}

		inline auto fill(char c) noexcept -> void
		{
			fill(CharAttributes{c});
		}

		inline auto clear() noexcept -> void
		{
			fill(' ');
		}

		inline auto draw([[maybe_unused]] WritableAreaView& view) noexcept -> void override
		{
			if (not m_widget)
				return;
			auto selfView = WritableAreaView{*this, m_viewport};
			m_widget->draw(selfView);
			// Draw scrollbars
			// Apply to view (applique la portion délimitée par viewport du buffer sur view)
			// view.applyArea(m_widget->getBuffer(), m_viewport);
			drawFinished();
		}

	protected:
		bool m_fullRenderRequested = true;
		Viewport m_viewport;
		std::unique_ptr<Widget> m_widget;
	};
}

export module CppUtils.Math.Utility;

import std;
import CppUtils.Type.Concept;

export namespace CppUtils::Math
{
	// Plus utile en C++23 (std::abs constexpr)
	[[nodiscard]] inline constexpr auto absolute(auto number) -> decltype(auto)
	{
		if constexpr (std::unsigned_integral<decltype(number)>)
			return number;
		else if constexpr (std::floating_point<decltype(number)>)
			return number < 0 ? -number : number;
		else
			return number < 0 ?
				static_cast<std::make_unsigned_t<decltype(number)>>(-number) :
				static_cast<std::make_unsigned_t<decltype(number)>>(number);
	}

	static_assert(absolute(0) == 0u);
	static_assert(absolute(1) == 1u);
	static_assert(absolute(-1) == 1u);
	static_assert(absolute(0.0) == 0.0);
	static_assert(absolute(1.5) == 1.5);
	static_assert(absolute(-1.5) == 1.5);
	static_assert(absolute(0u) == 0u);
	static_assert(absolute(1u) == 1u);

	template<Type::Numeric T>
	[[nodiscard]] inline constexpr auto isBetween(T value, T low, T high) noexcept -> bool
	{
		return low <= value and value <= high;
	}

	static_assert(isBetween(5, 0, 10));
	static_assert(not isBetween(-5, 0, 10));
	static_assert(not isBetween(15, 0, 10));
	static_assert(isBetween(5.0, 0.0, 10.0));
	static_assert(not isBetween(-5.0, 0.0, 10.0));
	static_assert(not isBetween(15.0, 0.0, 10.0));
	static_assert(isBetween(5.0f, 0.0f, 10.0f));
	static_assert(not isBetween(-5.0f, 0.0f, 10.0f));
	static_assert(not isBetween(15.0f, 0.0f, 10.0f));
}

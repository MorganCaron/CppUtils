module;

#include <CppUtils/System/OS.hpp>

#if defined(OS_WINDOWS)
#	include <Windows.h>
#elif defined(OS_LINUX)
#	include <unistd.h>
#	include <sys/types.h>
#	include <sys/mman.h>

#	include <wayland-client-core.h>
#	include <wayland-client-protocol.h>
#	include <xdg-shell.h>
// #	include <wayland-cursor.h>
#endif

export module CppUtils.Window;

import std;

import CppUtils.Container.Size2d;
import CppUtils.Logger;
import CppUtils.Memory;
import CppUtils.String;
import CppUtils.System;
import CppUtils.Window.Wayland;

namespace CppUtils::Window
{
	using Logger = CppUtils::Logger<"CppUtils">;

#if defined(OS_LINUX)
	namespace Wayland
	{
		inline constexpr const auto bytesPerPixel = std::size_t{4};
	}

	inline auto xdg_wm_base_ping([[maybe_unused]] void* data, xdg_wm_base* xdg_wm_base, std::uint32_t serial) -> void
	{
		xdg_wm_base_pong(xdg_wm_base, serial);
	}

	inline const auto windowManagerBaseListener = xdg_wm_base_listener{
		.ping = xdg_wm_base_ping,
	};

	inline auto global_registry_handler(
		void* data,
		wl_registry* registry,
		std::uint32_t id,
		const char* interface,
		std::uint32_t version) noexcept -> void
	{
		static const auto waylandRegistryHandlers = std::unordered_map<std::string_view, Wayland::RegisterHandler>{
			Wayland::makeHandlerPair(wl_compositor_interface, Wayland::globals.compositor, 3, 4),
			Wayland::makeHandlerPair(wl_shm_interface, Wayland::globals.sharedMemory, 1, 1),
			Wayland::makeHandlerPair(xdg_wm_base_interface, Wayland::globals.windowManagerBase, 1, 1, [data]() -> void {
			xdg_wm_base_add_listener(Wayland::globals.windowManagerBase.get(), &windowManagerBaseListener, data);
		})};
		auto interfaceName = std::string_view{interface};
		if (const auto& iterator = waylandRegistryHandlers.find(interfaceName); iterator != std::cend(waylandRegistryHandlers))
		{
			iterator->second(registry, id, version);
			Logger::print<"success">("{}", interfaceName);
		}
		else
			Logger::print<"warning">("{}", interfaceName);
	}

	inline auto global_registry_remover(
		[[maybe_unused]] void* data,
		[[maybe_unused]] wl_registry* registry,
		[[maybe_unused]] std::uint32_t id) noexcept -> void
	{}

	inline const auto registryListener = wl_registry_listener{
		.global = global_registry_handler,
		.global_remove = global_registry_remover,
	};

	inline auto wl_buffer_release([[maybe_unused]] void* data, [[maybe_unused]] wl_buffer* buffer) -> void
	{
		// Todo: basculer sur la frame suivante
	}

	inline const auto bufferListener = wl_buffer_listener{
		.release = wl_buffer_release,
	};

	inline auto xdg_surface_configure(
		void* data,
		xdg_surface* xdg_surface,
		std::uint32_t serial) -> void;

	inline const auto surfaceListener = xdg_surface_listener{
		.configure = &Window::xdg_surface_configure,
	};
#endif

	export class Window final
	{
	public:
		enum Style : uint8_t
		{
			None = 0,
			HasBorder = 0b1,
			HasTitleBar = HasBorder | 0b10,
			IsMinimizable = HasTitleBar | 0b100,
			IsResizeable = HasBorder | 0b1000,
			IsCloseable = HasTitleBar | 0b1'0000
		};

#if defined(OS_LINUX)
		struct ImageStorage final
		{
			inline ImageStorage() = default;

			inline explicit ImageStorage(Container::Size2d<std::size_t> size):
				m_size{std::move(size)}
			{
				const auto strideSize = m_size.width * Wayland::bytesPerPixel;
				const auto screenBufferSize = strideSize * m_size.height;
				const auto bufferSize = screenBufferSize * 3; // triple buffering

				m_fileDescriptor = System::FileDescriptor{System::allocateSharedMemory(bufferSize, "WaylandBuffer").value()};
				pixels = System::MappedSharedMemory{m_fileDescriptor, bufferSize};
				pool.reset(wl_shm_create_pool(Wayland::globals.sharedMemory.get(), m_fileDescriptor.get(), static_cast<std::int32_t>(bufferSize)));
				buffer.reset(
					wl_shm_pool_create_buffer(
						pool.get(),
						static_cast<std::int32_t>(screenBufferSize * 0),
						static_cast<std::int32_t>(m_size.width),
						static_cast<std::int32_t>(m_size.height),
						static_cast<std::int32_t>(strideSize),
						WL_SHM_FORMAT_ARGB8888)); // WL_SHM_FORMAT_XRGB8888

				wl_buffer_add_listener(buffer.get(), &bufferListener, nullptr);
			}

			ImageStorage(ImageStorage&&) noexcept = default;
			ImageStorage& operator=(ImageStorage&&) noexcept = default;

			[[nodiscard]] inline auto getSize() const noexcept -> const auto&
			{
				return m_size;
			}

		private:
			Container::Size2d<std::size_t> m_size;
			System::FileDescriptor m_fileDescriptor;

		public:
			System::MappedSharedMemory pixels;
			Wayland::SharedMemoryPool pool = {nullptr, wl_shm_pool_destroy};
			Wayland::Buffer buffer = {nullptr, wl_buffer_destroy};
		};
#endif

#if defined(OS_WINDOWS)
		[[nodiscard]] static inline auto generateStyle(Style style) const noexcept -> DWORD
		{
			auto windowStyle = DWORD{0};
			if (style & Style::HasBorder)
				windowStyle |= WS_BORDER;
			if (style & Style::HasTitleBar)
				windowStyle |= WS_CAPTION;
			if (style & Style::IsMinimizable)
				windowStyle |= WS_MINIMIZEBOX;
			if (style & Style::IsResizeable)
				windowStyle |= WS_MAXIMIZEBOX | WS_THICKFRAME;
			if (style & Style::IsCloseable)
				windowStyle |= WS_SYSMENU;
			return windowStyle;
		}
#endif

		inline auto initWindowManager() const -> std::expected<void, std::string>
		{
			using namespace std::literals;
#if defined(OS_LINUX)
			if (Wayland::globals.display)
				return {};
			Wayland::globals.display.reset(wl_display_connect(nullptr));
			if (not Wayland::globals.display)
				return std::unexpected{"Failed to connect to Wayland display"s};
			auto* display = Wayland::globals.display.get();
			Wayland::globals.registry.reset(wl_display_get_registry(display));
			wl_registry_add_listener(Wayland::globals.registry.get(), &registryListener, &Wayland::globals);
			wl_display_roundtrip(display);
			if (not Wayland::globals.compositor)
				return std::unexpected{"Failed to find a Wayland compositor"s};
#endif
			return {};
		}

		inline auto openWindow() -> std::expected<void, std::string_view>
		{
			using namespace std::literals;
#if defined(OS_WINDOWS)
			auto hInstance = GetModuleHandleA(nullptr);
			m_window = CreateWindowEx(
				0, windowClassName, m_title.c_str(), generateStyle(m_style), CW_USEDEFAULT, CW_USEDEFAULT, size.width, size.height, nullptr, nullptr, hInstance, nullptr);
			if (m_window == nullptr)
				return std::unexpected{"Window creation failed."sv};
#elif defined(OS_LINUX)
			surface.reset(wl_compositor_create_surface(Wayland::globals.compositor.get()));
			if (not surface)
				return std::unexpected{"Failed to create a Wayland surface"sv};
			shellSurface.reset(xdg_wm_base_get_xdg_surface(Wayland::globals.windowManagerBase.get(), surface.get()));
			if (not shellSurface)
				return std::unexpected{"Failed to create a Wayland shell surface"sv};
			xdg_surface_add_listener(shellSurface.get(), &surfaceListener, this);
			topLevel.reset(xdg_surface_get_toplevel(shellSurface.get()));
			xdg_toplevel_set_title(topLevel.get(), std::data(m_title));
#endif
			return {};
		}

	public:
		inline Window(std::string title, Container::Size2d<std::size_t> size, Style style = Style{Style::IsMinimizable | Style::IsCloseable}):
			m_title{std::move(title)},
			m_style{style},
			m_size{size}
		{
			initWindowManager();
			wl_display_roundtrip(Wayland::globals.display.get());
			// m_imageStorage = ImageStorage{size};
			openWindow();
			wl_surface_commit(surface.get());
			// wl_display_roundtrip(Wayland::globals.display.get());
			// wl_display_dispatch(Wayland::globals.display.get());
			wl_display_flush(Wayland::globals.display.get());
		}

		inline ~Window()
		{
#if defined(OS_WINDOWS)
			/*
			if (data != MAP_FAILED)
				munmap(data, bufferSize);
			*/
#endif
		}

		inline Window(const Window&) = delete;
		inline Window& operator=(const Window&) = delete;

	public:
		inline auto setTitle(std::string title) noexcept -> void
		{
			m_title = std::move(title);
		}

		[[nodiscard]] inline auto getTitle() const noexcept -> const auto&
		{
			return m_title;
		}

		inline auto setSize(Container::Size2d<std::size_t> size) noexcept -> void
		{
			m_size = size;
		}

		[[nodiscard]] inline auto getSize() const noexcept -> const auto&
		{
			return m_size;
		}

		[[nodiscard]] inline auto getPixels() const noexcept -> auto*
		{
			return reinterpret_cast<std::uint32_t*>(m_imageStorage.pixels.get());
		}

		inline auto runLoop() -> void
		{
			auto result = 0;
			while ((result = wl_display_dispatch(Wayland::globals.display.get())) != -1)
				std::cout << "Event received, result = " << result << std::endl;
			std::cout << "Wayland dispatch exited with " << result << std::endl;
		}

		inline auto update() -> void
		{
			std::cout << "update" << std::endl;
			wl_surface_attach(surface.get(), m_imageStorage.buffer.get(), 0, 0);
			wl_surface_damage(surface.get(), 0, 0, std::numeric_limits<std::int32_t>::max(), std::numeric_limits<std::int32_t>::max());
			wl_surface_commit(surface.get());
			wl_display_flush(Wayland::globals.display.get());
		}

	private:
		std::string m_title;
		[[maybe_unused]] Style m_style;
		Container::Size2d<std::size_t> m_size;
#if defined(OS_WINDOWS)
		static inline constexpr auto windowClassName = L"Window";
		HWND m_window;
#elif defined(OS_LINUX)
		Wayland::Surface surface = {nullptr, wl_surface_destroy};
		Wayland::ShellSurface shellSurface = {nullptr, xdg_surface_destroy};
		Wayland::TopLevel topLevel = {nullptr, xdg_toplevel_destroy};

	public:
		ImageStorage m_imageStorage;
#endif
	};

	inline auto drawFrame(Window& window) -> void
	{
		std::cout << "drawFrame" << std::endl;
		const auto& imageSize = window.getSize();
		if (not window.m_imageStorage.buffer)
		{
			std::cout << "ImageStorage" << std::endl;
			window.m_imageStorage = Window::ImageStorage{imageSize};
		}
		auto* pixels = window.getPixels();
		for (auto y = 0uz; y < imageSize.height; ++y)
		{
			for (auto x = 0uz; x < imageSize.width; ++x)
				if ((x + y / 8 * 8) % 16 < 8)
					pixels[y * imageSize.width + x] = 0xFF'66'66'66;
				else
					pixels[y * imageSize.width + x] = 0xFF'EE'EE'EE;
		}
	}

	inline auto xdg_surface_configure(
		void* data,
		xdg_surface* xdg_surface,
		std::uint32_t serial) -> void
	{
		std::cout << "Surface configure !" << std::endl;
		auto& window = *static_cast<Window*>(data);
		xdg_surface_ack_configure(xdg_surface, serial);

		drawFrame(window);
		window.update();
	}
}

module;

#include <CppUtils/System/OS.hpp>

#if defined(OS_WINDOWS)
#	include <Windows.h>
#elif defined(OS_LINUX)
#	include <unistd.h>
#	include <sys/types.h>
#	include <sys/mman.h>

#	include <wayland-client-core.h>
#	include <wayland-client-protocol.h>
#	include <xdg-shell.h>
// #	include <wayland-cursor.h>
#endif

export module CppUtils.Window;

import std;

import CppUtils.Container.Size2d;
import CppUtils.Logger;
import CppUtils.Memory;
import CppUtils.String;
import CppUtils.System;

namespace CppUtils::Window
{
	using Logger = CppUtils::Logger<"CppUtils">;

#if defined(OS_LINUX)
	namespace Wayland
	{
		using Display = Memory::UniquePtrWithDestructor<wl_display>;
		using Registry = Memory::UniquePtrWithDestructor<wl_registry>;
		using Compositor = Memory::UniquePtrWithDestructor<wl_compositor>;
		using SharedMemory = Memory::UniquePtrWithDestructor<wl_shm>;
		using SharedMemoryPool = Memory::UniquePtrWithDestructor<wl_shm_pool>;
		using Surface = Memory::UniquePtrWithDestructor<wl_surface>;
		using ShellSurface = Memory::UniquePtrWithDestructor<xdg_surface>;
		using TopLevel = Memory::UniquePtrWithDestructor<xdg_toplevel>;
		using Buffer = Memory::UniquePtrWithDestructor<wl_buffer>;
		using WmBase = Memory::UniquePtrWithDestructor<xdg_wm_base>;

		struct Globals final
		{
			Display display = {nullptr, wl_display_disconnect};
			Registry registry = {nullptr, wl_registry_destroy};
			Compositor compositor = {nullptr, wl_compositor_destroy};
			SharedMemory sharedMemory = {nullptr, wl_shm_destroy};
			WmBase wmBase = {nullptr, xdg_wm_base_destroy};
		};
		inline auto globals = Wayland::Globals{};

		using RegisterHandler = std::function<void(wl_registry*, std::uint32_t, std::uint32_t)>;

		inline constexpr const auto bytesPerPixel = std::size_t{4};
	}

	template<class T>
	inline auto makeHandlerPair(
		const wl_interface& interface,
		Memory::UniquePtrWithDestructor<T>& registerContainer,
		std::uint32_t minVersion,
		std::uint32_t maxVersion) -> std::pair<std::string_view, Wayland::RegisterHandler>
	{
		return {
			std::string_view{interface.name},
			[&registerContainer, &interface, minVersion, maxVersion](auto* registry, auto id, auto serverVersion) -> void {
			using namespace std::literals;
			if (serverVersion < minVersion)
				throw std::runtime_error{interface.name + " trop ancien"s};
			registerContainer.reset(static_cast<T*>(wl_registry_bind(registry, id, &interface, std::min(serverVersion, maxVersion))));
		}};
	}

	inline auto global_registry_handler(
		void* data,
		wl_registry* registry,
		std::uint32_t id,
		const char* interface,
		std::uint32_t version) noexcept -> void
	{
		auto& waylandGlobals = *static_cast<Wayland::Globals*>(data);
		static const auto waylandRegistryHandlers = std::unordered_map<std::string_view, Wayland::RegisterHandler>{
			makeHandlerPair(wl_compositor_interface, waylandGlobals.compositor, 3, 4),
			makeHandlerPair(wl_shm_interface, waylandGlobals.sharedMemory, 1, 1),
			makeHandlerPair(xdg_wm_base_interface, waylandGlobals.wmBase, 1, 1)};
		auto interfaceName = std::string_view{interface};
		if (const auto& iterator = waylandRegistryHandlers.find(interfaceName); iterator != std::cend(waylandRegistryHandlers))
		{
			iterator->second(registry, id, version);
			Logger::print<"success">("{}", interfaceName);
		}
		else
			Logger::print<"warning">("{}", interfaceName);
	}

	inline auto global_registry_remover(
		[[maybe_unused]] void* data,
		[[maybe_unused]] wl_registry* registry,
		[[maybe_unused]] std::uint32_t id) noexcept -> void
	{}

	inline const auto registryListener = wl_registry_listener{
		.global = global_registry_handler,
		.global_remove = global_registry_remover};

	inline auto wl_buffer_release([[maybe_unused]] void* data, wl_buffer* buffer) -> void
	{
		wl_buffer_destroy(buffer);
	}

	inline const auto bufferListener = wl_buffer_listener{
		.release = wl_buffer_release};

	inline auto xdg_surface_configure(
		void* data,
		xdg_surface* xdg_surface,
		std::uint32_t serial) -> void;

	inline const auto surfaceListener = xdg_surface_listener{
		.configure = &Window::xdg_surface_configure};
#endif

	export class Window final
	{
	public:
		enum Style : uint8_t
		{
			None = 0,
			HasBorder = 0b1,
			HasTitleBar = HasBorder | 0b10,
			IsMinimizable = HasTitleBar | 0b100,
			IsResizeable = HasBorder | 0b1000,
			IsCloseable = HasTitleBar | 0b1'0000
		};

	private:
#if defined(OS_WINDOWS)
		[[nodiscard]] static inline auto generateStyle(Style style) const noexcept -> DWORD
		{
			auto windowStyle = DWORD{0};
			if (style & Style::HasBorder)
				windowStyle |= WS_BORDER;
			if (style & Style::HasTitleBar)
				windowStyle |= WS_CAPTION;
			if (style & Style::IsMinimizable)
				windowStyle |= WS_MINIMIZEBOX;
			if (style & Style::IsResizeable)
				windowStyle |= WS_MAXIMIZEBOX | WS_THICKFRAME;
			if (style & Style::IsCloseable)
				windowStyle |= WS_SYSMENU;
			return windowStyle;
		}
#endif

		inline auto initWindowManager() const -> std::expected<void, std::string>
		{
			using namespace std::literals;
#if defined(OS_LINUX)
			if (Wayland::globals.display)
				return {};
			Wayland::globals.display.reset(wl_display_connect(nullptr));
			if (not Wayland::globals.display)
				return std::unexpected{"Failed to connect to Wayland display"s};
			auto* display = Wayland::globals.display.get();
			Wayland::globals.registry.reset(wl_display_get_registry(display));
			wl_registry_add_listener(Wayland::globals.registry.get(), &registryListener, &Wayland::globals);
			// wl_display_dispatch(display);
			wl_display_roundtrip(display);
			if (not Wayland::globals.compositor)
				return std::unexpected{"Failed to find a Wayland compositor"s};
#endif
			return {};
		}

		inline auto openWindow() -> std::expected<void, std::string_view>
		{
			using namespace std::literals;
#if defined(OS_WINDOWS)
			auto hInstance = GetModuleHandleA(nullptr);
			m_window = CreateWindowEx(
				0, windowClassName, m_title.c_str(), generateStyle(m_style), CW_USEDEFAULT, CW_USEDEFAULT, size.width, size.height, nullptr, nullptr, hInstance, nullptr);
			if (m_window == nullptr)
				return std::unexpected{"Window creation failed."sv};
#elif defined(OS_LINUX)
			waylandSurface.reset(wl_compositor_create_surface(Wayland::globals.compositor.get()));
			if (not waylandSurface)
				return std::unexpected{"Failed to create a Wayland surface"sv};
			waylandShellSurface.reset(xdg_wm_base_get_xdg_surface(Wayland::globals.wmBase.get(), waylandSurface.get()));
			if (not waylandShellSurface)
				return std::unexpected{"Failed to create a Wayland shell surface"sv};
			xdg_surface_add_listener(waylandShellSurface.get(), &surfaceListener, this);
			topLevel.reset(xdg_surface_get_toplevel(waylandShellSurface.get()));
			xdg_toplevel_set_title(topLevel.get(), std::data(m_title));
#endif
			return {};
		}

	public:
		inline Window(std::string title, Container::Size2d<std::size_t> size, Style style = Style{Style::IsMinimizable | Style::IsCloseable}):
			m_title{std::move(title)},
			m_size{std::move(size)},
			m_style{style}
		{
			initWindowManager();
			openWindow();
		}

		inline ~Window()
		{
#if defined(OS_WINDOWS)
			if (data != MAP_FAILED)
				munmap(data, bufferSize);
#endif
		}

		inline Window(const Window&) = delete;
		inline Window& operator=(const Window&) = delete;

	public:
		inline auto setTitle(std::string title) noexcept -> void
		{
			m_title = std::move(title);
		}

		[[nodiscard]] inline auto getTitle() const noexcept -> const auto&
		{
			return m_title;
		}

		inline auto setSize(Container::Size2d<std::size_t> size) noexcept -> void
		{
			m_size = std::move(size);
		}

		[[nodiscard]] inline auto getSize() const noexcept -> const auto&
		{
			return m_size;
		}

		inline auto runLoop() -> void
		{
			while (wl_display_dispatch(Wayland::globals.display.get()) != -1)
			{
				// Event loop
			}
		}

		inline auto draw(const Wayland::Buffer& buffer) -> void
		{
			wl_surface_attach(waylandSurface.get(), buffer.get(), 0, 0);
			// wl_surface_damage(waylandSurface.get(), 0, 0, std::numeric_limits<std::int32_t>::max(), std::numeric_limits<std::int32_t>::max());
			wl_surface_commit(waylandSurface.get());
		}

	private:
		std::string m_title;
		Container::Size2d<std::size_t> m_size;
		[[maybe_unused]] Style m_style;
#if defined(OS_WINDOWS)
		static inline constexpr auto windowClassName = L"Window";
		HWND m_window;
#elif defined(OS_LINUX)
		Wayland::Surface waylandSurface = {nullptr, wl_surface_destroy};
		Wayland::ShellSurface waylandShellSurface = {nullptr, xdg_surface_destroy};
		Wayland::TopLevel topLevel = {nullptr, xdg_toplevel_destroy};
		Wayland::SharedMemoryPool waylandSharedMemoryPool = {nullptr, wl_shm_pool_destroy};
		Wayland::Buffer waylandBuffer = {nullptr, wl_buffer_destroy};
#endif
	};

	[[nodiscard]] inline auto drawFrame(Window& window) -> std::expected<Wayland::Buffer, std::string_view>
	{
		const auto& windowSize = window.getSize();
		const auto strideSize = windowSize.width * Wayland::bytesPerPixel;
		const auto screenBufferSize = strideSize * windowSize.height;
		const auto bufferSize = screenBufferSize * 2;
		auto fileDescriptor = System::allocateSharedMemory(bufferSize, "WaylandBuffer");
		if (not fileDescriptor)
			return std::unexpected{fileDescriptor.error()};

		auto data = System::mapSharedMemory(fileDescriptor.value(), bufferSize);
		if (not data)
			return std::unexpected{data.error()};

		auto pool = Wayland::SharedMemoryPool{wl_shm_create_pool(Wayland::globals.sharedMemory.get(), fileDescriptor->get(), static_cast<std::int32_t>(bufferSize)), wl_shm_pool_destroy};
		auto buffer = Wayland::Buffer{
			wl_shm_pool_create_buffer(
				pool.get(),
				static_cast<std::int32_t>(screenBufferSize * 0),
				static_cast<std::int32_t>(windowSize.width),
				static_cast<std::int32_t>(windowSize.height),
				static_cast<std::int32_t>(strideSize),
				WL_SHM_FORMAT_ARGB8888), // WL_SHM_FORMAT_XRGB8888
			wl_buffer_destroy};

		// damier
		std::memset(data.value(), 255, bufferSize);
		auto* pixels = reinterpret_cast<std::uint32_t*>(data.value());
		for (std::size_t y = 0; y < windowSize.height; ++y)
		{
			for (std::size_t x = 0; x < windowSize.width; ++x)
				if ((x + y / 8 * 8) % 16 < 8)
					pixels[y * windowSize.width + x] = 0xFF'66'66'66;
				else
					pixels[y * windowSize.width + x] = 0xFF'EE'EE'EE;
		}

		munmap(data.value(), bufferSize);
		wl_buffer_add_listener(buffer.get(), &bufferListener, nullptr);
		return buffer;
	}

	inline auto xdg_surface_configure(
		void* data,
		xdg_surface* xdg_surface,
		std::uint32_t serial) -> void
	{
		auto& window = *static_cast<Window*>(data);
		xdg_surface_ack_configure(xdg_surface, serial);

		auto buffer = drawFrame(window);
		if (not buffer)
			throw std::runtime_error{std::data(buffer.error())};
		window.draw(buffer.value());
	}
}

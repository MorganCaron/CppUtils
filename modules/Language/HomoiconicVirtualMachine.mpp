export module CppUtils.Language.HomoiconicVirtualMachine;

import std;
import CppUtils.String;
import CppUtils.Type;
import CppUtils.Language.GenericVirtualMachine;

export namespace CppUtils::Language::Homoiconic
{
	inline constexpr auto interpreter = []<auto... functions>(Type::Specializes<Cursor> auto& cursor, const ASTNode& instruction, auto& virtualMachine) constexpr -> std::expected<void, std::string> {
		using namespace std::literals;
		using namespace String::Literals;
		auto& context = virtualMachine.context;
		auto& [rootAst, hashTable, scopes] = context;
		const auto instructionToken = instruction.value;
		auto grammar = [instructionToken, &scopes]() -> std::reference_wrapper<ASTNode> {
			const auto range = scopes | std::views::reverse;
			auto it = std::ranges::find_if(range, [instructionToken](const auto scope) -> bool { return scope.get().exists(instructionToken); });
			return it != std::ranges::end(range) ? *it : scopes.front();
		}();
		if (grammar.get().exists(instructionToken))
		{
			auto lexemes = std::ref(grammar.get()[instructionToken].nodes);
			for (auto instructionPosition = 0uz; instructionPosition < std::size(lexemes.get()); ++instructionPosition)
			{
				const auto& lexeme = lexemes.get()[instructionPosition];
				if (auto result = virtualMachine.template execute<functions...>(cursor, lexeme); not result) [[unlikely]]
					return std::unexpected{std::move(result.error())};
				lexemes = std::ref(grammar.get()[instructionToken].nodes);
			}
		}
		else
			switch (instructionToken)
			{
			case "call"_token:
				if constexpr (sizeof...(functions) > 0)
				{
					if (std::empty(instruction.nodes)) [[unlikely]]
						return std::unexpected{R"(Instruction "call": Missing parameter)"};
					else if (auto result = Type::Tuple::visitAt(std::make_tuple(functions...), instruction.nodes[0].value, [&cursor, &virtualMachine](auto&& function) -> decltype(auto) { return function(cursor, virtualMachine); }); not result)
						return std::unexpected{std::string{result.error()}};
				}
				break;
			default:
				return std::unexpected{std::format(R"(Unknown instruction "{}")", String::getNameOrValue(instructionToken, hashTable))};
			}
		return {};
	};

	struct Context final
	{
		// clang-format off
		ASTNode rootAst = {0uz, {
			ASTNode{String::hash("main"), {
				ASTNode{String::hash("executeInstruction")},
				ASTNode{String::hash("advanceCursor")}
			}},
			ASTNode{String::hash("executeInstruction"), {
				ASTNode{String::hash("call"), {ASTNode{0}}}
			}},
			ASTNode{String::hash("advanceCursor"), {
				ASTNode{String::hash("call"), {ASTNode{1}}}
			}}
		}};
		// clang-format on
		String::HashTable<char> hashTable = String::makeHashTable<char>(
			"main",
			"executeInstruction",
			"advanceCursor",
			"call");
		std::vector<std::reference_wrapper<ASTNode>> scopes = {std::ref(rootAst)};
	};

	template<auto inspector = nullptr>
	using VirtualMachine = GenericVirtualMachine<Context, interpreter, inspector>;

	inline constexpr auto printInstruction = [](const Type::Specializes<Cursor> auto&, const ASTNode& instruction, Context& context) -> std::expected<void, std::string> {
		std::println("{}", String::getNameOrValue(instruction.value, context.hashTable));
		return {};
	};

	inline constexpr auto executeInstruction = [](Type::Specializes<Cursor> auto& cursor, auto& virtualMachine) -> std::expected<void, std::string> {
		virtualMachine.template execute<>(cursor, ASTNode{static_cast<Symbol>(cursor.getCurrent())});
		return {};
	};

	inline constexpr auto advanceCursor = [](Type::Specializes<Cursor> auto& cursor, [[maybe_unused]] auto& virtualMachine) -> std::expected<void, std::string> {
		++cursor.position;
		return {};
	};
}

export module CppUtils.Language.CSV.Mapping;

import std;

import CppUtils.String;
import CppUtils.Type.Mapping;

export namespace CppUtils::Language::CSV
{
	using Line = std::vector<std::string_view>;

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toStruct(const auto& csvLine) -> Object
	{
		using CSVMapping = typename Mapping::CSVMapping;
		using StructMapping = typename Mapping::StructMapping;
		using FunctionMapping = typename Mapping::FunctionMapping;
		static_assert(std::is_default_constructible_v<Object>);
		auto object = Object{};
		std::apply([&](auto&&... csvPairs) -> void {
			([&](auto&& csvPair) -> void {
				using CSVPair = std::remove_cvref_t<decltype(csvPair)>;
				constexpr auto token = CSVPair::lhs;
				constexpr auto csvColumnPosition = std::get<0>(CSVPair::rhs);
				if (csvColumnPosition < std::size(csvLine))
				{
					constexpr auto memberPointer = std::get<0>(StructMapping::template toRhs<token>());
					auto& member = object.*memberPointer;
					using MemberType = std::remove_cvref_t<decltype(member)>;
					auto value = std::string_view{csvLine[csvColumnPosition]};
					if constexpr (FunctionMapping::template containsLhs<token>())
						FunctionMapping::template toSingleRhs<token>()(member, value);
					else if constexpr (std::same_as<MemberType, std::string_view>)
						member = value;
					else if constexpr (std::same_as<MemberType, std::string>)
						member = value;
					else if constexpr (std::integral<MemberType> or std::floating_point<MemberType>)
						std::from_chars(std::data(value), std::data(value) + std::size(value), member);
				}
			}(csvPairs), ...);
		}, typename CSVMapping::Values{});
		return object;
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toStructs(
		const auto& lines,
		std::size_t dropNFirstLines = 0,
		std::vector<Object>&& objects = {}) -> std::vector<Object>
	{
		for (auto i = dropNFirstLines; i < std::size(lines); ++i)
			if (const auto& line = lines[i]; not std::empty(line))
				objects.push_back(toStruct<Object, Mapping>(line));
		return std::move(objects);
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toCSV(const Object& object, std::string_view separator = ";") -> std::string
	{
		using CSVMapping = typename Mapping::CSVMapping;
		using StructMapping = typename Mapping::StructMapping;
		constexpr auto maxPosition = []() -> std::size_t {
			auto max = 0uz;
			std::apply([&](auto&&... pairs) {
				((max = std::max(max, static_cast<std::size_t>(std::get<0>(std::remove_cvref_t<decltype(pairs)>::rhs)))), ...);
			}, typename CSVMapping::Values{});
			return max;
		}();
		auto columns = std::vector<std::string>(maxPosition + 1);
		std::apply([&](auto&&... csvPairs) -> void {
			([&](auto&& csvPair) -> void {
				using CSVPair = std::remove_cvref_t<decltype(csvPair)>;
				constexpr auto token = CSVPair::lhs;
				constexpr auto csvColumnPosition = std::get<0>(CSVPair::rhs);
				constexpr auto memberPointer = std::get<0>(StructMapping::template toRhs<token>());
				columns[csvColumnPosition] = String::formatValue(object.*memberPointer);
			}(csvPairs), ...);
		}, typename CSVMapping::Values{});
		return String::concatenateStringsWithSeparator(columns, separator);
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toCSV(
		const std::vector<Object>& objects,
		std::string_view columnSeparator = ";",
		std::string_view lineSeparator = "\n") -> std::string
	{
		auto csv = std::string{};
		for (const auto& object : objects)
		{
			if (not std::empty(csv))
				csv += lineSeparator;
			csv += toCSV<Object, Mapping>(object, columnSeparator);
		}
		return csv;
	}
}

export module CppUtils.Language.CSV.Mapping;

import std;

import CppUtils.String;
import CppUtils.Type.Mapping;
import CppUtils.FileSystem;

export namespace CppUtils::Language::CSV
{
	using Line = std::vector<std::string_view>;

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toStruct(const auto& csvLine) -> Object
	{
		using CSVMapping = typename Mapping::CSVMapping;
		using StructMapping = typename Mapping::StructMapping;
		using FunctionMapping = typename Mapping::FunctionMapping;
		static_assert(std::is_default_constructible_v<Object>);
		auto object = Object{};
		std::apply([&](auto&&... csvPairs) -> void {
			([&](auto&& csvPair) -> void {
				using CSVPair = std::remove_cvref_t<decltype(csvPair)>;
				constexpr auto token = CSVPair::lhs;
				constexpr auto csvColumnPosition = std::get<0>(CSVPair::rhs);
				if (csvColumnPosition < std::size(csvLine))
				{
					constexpr auto memberPointer = std::get<0>(StructMapping::template toRhs<token>());
					auto& member = object.*memberPointer;
					using MemberType = std::remove_cvref_t<decltype(member)>;
					auto value = std::string_view{csvLine[csvColumnPosition]};
					if constexpr (FunctionMapping::template containsLhs<token>())
						FunctionMapping::template toSingleRhs<token>()(member, value);
					else if constexpr (std::same_as<MemberType, std::string_view>)
						member = value;
					else if constexpr (std::same_as<MemberType, std::string>)
						member = value;
					else if constexpr (std::integral<MemberType> or std::floating_point<MemberType>)
						std::from_chars(std::data(value), std::data(value) + std::size(value), member);
				}
			}(csvPairs), ...);
		}, typename CSVMapping::Values{});
		return object;
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toStruct(std::string_view csvLine, std::string_view separator = ";") -> Object
	{
		const auto tokens = csvLine
			| std::views::split(separator)
			| std::views::transform([](auto&& range) { return std::string_view{range}; })
			| std::ranges::to<std::vector<std::string_view>>();
		return toStruct<Object, Mapping>(tokens);
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toStructs(
		std::string_view csv,
		std::string_view columnSeparator = ";",
		std::string_view lineSeparator = "\n",
		std::size_t dropNFirstLines = 0,
		std::vector<Object>&& objects = {}) -> std::vector<Object>
	{
		const auto lines = csv
			| std::views::split(lineSeparator)
			| std::views::transform([](auto&& range) { return std::string_view{range}; })
			| std::ranges::to<std::vector<std::string_view>>();
		for (auto i = dropNFirstLines; i < std::size(lines); ++i)
			if (const auto trimmedLine = String::trimString(lines[i]); not std::empty(trimmedLine))
				objects.push_back(toStruct<Object, Mapping>(trimmedLine, columnSeparator));
		return std::move(objects);
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toCSV(const Object& object, std::string_view separator = ";") -> std::string
	{
		using CSVMapping = typename Mapping::CSVMapping;
		using StructMapping = typename Mapping::StructMapping;
		constexpr auto maxPosition = []() -> std::size_t {
			auto max = 0uz;
			std::apply([&](auto&&... pairs) {
				((max = std::max(max, static_cast<std::size_t>(std::get<0>(std::remove_cvref_t<decltype(pairs)>::rhs)))), ...);
			}, typename CSVMapping::Values{});
			return max;
		}();
		auto columns = std::vector<std::string>(maxPosition + 1);
		std::apply([&](auto&&... csvPairs) -> void {
			([&](auto&& csvPair) -> void {
				using CSVPair = std::remove_cvref_t<decltype(csvPair)>;
				constexpr auto token = CSVPair::lhs;
				constexpr auto csvColumnPosition = std::get<0>(CSVPair::rhs);
				constexpr auto memberPointer = std::get<0>(StructMapping::template toRhs<token>());
				columns[csvColumnPosition] = String::formatValue(object.*memberPointer);
			}(csvPairs), ...);
		}, typename CSVMapping::Values{});
		return String::concatenateStringsWithSeparator(columns, separator);
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto toCSV(
		const std::vector<Object>& objects,
		std::string_view columnSeparator = ";",
		std::string_view lineSeparator = "\n") -> std::string
	{
		auto csv = std::string{};
		for (const auto& object : objects)
		{
			if (not std::empty(csv))
				csv += lineSeparator;
			csv += toCSV<Object, Mapping>(object, columnSeparator);
		}
		return csv;
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto loadFile(
		const std::filesystem::path& filePath,
		std::string_view columnSeparator = ";",
		std::string_view lineSeparator = "\n",
		std::size_t dropNFirstLines = 0,
		std::vector<Object>&& elements = {}) -> std::vector<Object>
	{
		auto fileContent = FileSystem::String::read(filePath);
		return toStructs<Object, Mapping>(fileContent, columnSeparator, lineSeparator, dropNFirstLines, std::move(elements));
	}

	template<class Object, class Mapping>
	[[nodiscard]] inline auto loadDirectory(const std::filesystem::path& directory,
		std::string_view columnSeparator = ";",
		std::string_view lineSeparator = "\n",
		std::size_t dropNFirstLines = 0,
		std::vector<Object>&& elements = {}) -> std::vector<Object>
	{
		FileSystem::forFilesWithExtension(directory, ".csv", [&](const auto& filePath) {
			elements = loadFile<Object, Mapping>(filePath, columnSeparator, lineSeparator, dropNFirstLines, std::move(elements));
		});
		return std::move(elements);
	}
}

export module CppUtils.Language.TreeCompiler;

import std;
import CppUtils.Memory;
import CppUtils.Container.Tree;
import CppUtils.Language.VirtualMachine;
import CppUtils.Language.HighLevelLabelsCompiler;

export namespace CppUtils::Language::TreeCompiler
{
	template<class CharT>
	inline auto compile(const std::basic_string_view<CharT> source) -> Container::TokenTree
	{
		using namespace std::literals;
		constexpr auto treeCompiler = uR"(
				main(): Container::TokenTree* {
					(:N # TokenTree
						(0 # Source position
							(2@ # Call buildNode
						)
					X # return TokenTree
				}

				buildNode(std::size_t sourcePosition): void {
					# (4@ # Call skipSpaces
				}

				isEndOfFile: bool {
					
				}

				isSpace: bool {
					
				}

				incrementPosition(std::size_t sourcePosition): void {
					I
					(0, 1, 0+ # Increment position
					I
				}

				skipSpaces(std::size_t sourcePosition): void {
					(1: (1; (2;) # Source size
					(0, 1, 6=! (0, 6, 4? {
						(3: # char
							(1; # Source
								(1: (3, 6, 0, 0C # Source position
									(3; # Get char at position
								)
							)
						)
						(2@ # Call incrementPosition
					}
				}
				)"sv;
		auto compiler = HighLevelLabelsCompiler::compile(treeCompiler);
		return Memory::moveRawPointer(VirtualMachine::execute<
			Container::TokenTree*,
			std::size_t,
			bool,
			CharT,
			const decltype(source)*,
			std::basic_string<CharT>*>(
			compiler,
			&source,
			&decltype(source)::size,
			&decltype(source)::at,
			&std::basic_string<CharT>::push_back));
	}
}

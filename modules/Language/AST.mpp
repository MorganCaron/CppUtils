export module CppUtils.Language.AST;

import std;
import CppUtils.String;
import CppUtils.Container.Tree;

export namespace CppUtils::Language
{
	struct AST final
	{
		using Node = Container::Tree::Node<String::Token>;

		Node root;
		String::HashTable hashTable;

		inline explicit AST(std::string astName = "root", String::HashTable c_hashTable = {})
		{
			const auto token = String::hash(astName);
			root = Node{token};
			hashTable = std::move(c_hashTable);
			hashTable[token] = std::move(astName);
		}

		struct NodeView final
		{
			std::reference_wrapper<const Node> node;
			std::reference_wrapper<const AST> ast;

			inline explicit NodeView(const AST& ast):
				node{std::cref(ast.root)},
				ast{std::cref(ast)}
			{}

			inline explicit NodeView(const Node& node, const AST& ast):
				node{std::cref(node)},
				ast{std::cref(ast)}
			{}

			[[nodiscard]] inline auto get() const -> const Node&
			{
				return node.get();
			}

			[[nodiscard]] inline auto get(String::Token token) const -> const Node&
			{
				return get()[token];
			}

			inline auto to(String::Token token) -> NodeView&
			{
				node = std::cref(get(token));
				return *this;
			}

			template<class CharT>
			[[nodiscard]] inline auto getPrintableValue() const -> auto
			{
				return String::getNameOrValue<CharT>(get().value, ast.get().hashTable);
			}
		};
	};
}

namespace std
{
	template<class CharT>
	struct formatter<CppUtils::Language::AST::NodeView, CharT>
	{
		constexpr auto parse(std::format_parse_context& ctx) -> auto
		{
			return std::begin(ctx);
		}

		template<class FormatContext>
		inline auto format(const CppUtils::Language::AST::NodeView& nodeView, FormatContext& context) const -> decltype(context.out())
		{
			auto&& out = context.out();
			formatNode(nodeView, context);
			return std::format_to(out, "\n");
		}

	private:
		template<class FormatContext>
		inline auto formatNode(const CppUtils::Language::AST::NodeView& nodeView, FormatContext& context, std::string&& prefix = "") const -> void
		{
			const auto& [node, ast] = nodeView;
			auto&& out = context.out();
			std::format_to(out, "{}\n", nodeView.getPrintableValue<CharT>());
			const auto nbNodes = std::size(node.get().nodes);
			for (auto i = 0uz; i < nbNodes; ++i)
			{
				std::format_to(out, "{}{}─ ", prefix, (i != nbNodes - 1) ? "├" : "└");
				auto child = CppUtils::Language::AST::NodeView{node.get().nodes.at(i), ast};
				formatNode(child, context, prefix + ((i != nbNodes - 1) ? "│" : " ") + "  ");
			}
		}
	};

	template<class CharT>
	struct formatter<CppUtils::Language::AST, CharT>
	{
		constexpr auto parse(std::format_parse_context& ctx) -> auto
		{
			return std::begin(ctx);
		}

		template<class FormatContext>
		inline auto format(const CppUtils::Language::AST& ast, FormatContext& context) const -> decltype(context.out())
		{
			auto&& out = context.out();
			return std::format_to(out, "{}", CppUtils::Language::AST::NodeView{ast});
		}
	};
}

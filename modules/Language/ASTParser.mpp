export module CppUtils.Language.ASTParser;

import std;
import CppUtils.Container.Vector;
import CppUtils.String;
import CppUtils.Type;
import CppUtils.Language.AST;
import CppUtils.Language.MetaEvaluator;

export namespace CppUtils::Language
{
	struct ASTParser: public MetaEvaluator
	{
		ASTParser()
		{
			using namespace std::literals;
			using namespace String::Literals;

			functions["abort"_token] = [](Cursor&, const ASTNode&, MetaEvaluator&) -> std::expected<void, std::string_view> {
				return std::unexpected{"Abort"};
			};
			functions["return"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				context.exit = true;
				return {};
			};
			functions["syntaxError"_token] = [](Cursor&, const ASTNode&, MetaEvaluator&) -> std::expected<void, std::string_view> {
				return std::unexpected{"Syntax error"};
			};
			functions["enter"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scope = context.getScope();
				auto& scopeNodes = scope.nodes;
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"Missing scope token"};
				auto targetNodeId = scopeNodes.back().value;
				if (instruction.exists("delete"_token))
					scopeNodes.pop_back();
				context.scopes.push_back(std::ref(scope[targetNodeId]));
				return {};
			};
			functions["enterInLast"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scope = context.getScope();
				context.scopes.push_back(std::ref(scope.nodes.back()));
				return {};
			};
			functions["leave"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				if (std::size(context.scopes) <= 1)
					return std::unexpected("Cannot leave the global scope");
				context.scopes.pop_back();
				return {};
			};

			functions["new"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(instruction.nodes))
					scopeNodes.emplace_back(0);
				else
					scopeNodes.push_back(instruction.nodes.front());
				return {};
			};
			functions["delete"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scope = context.getScope();
				auto& scopeNodes = scope.nodes;
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"No node to delete"};
				if (std::empty(instruction.nodes))
					scopeNodes.pop_back();
				else if (auto it = scope.find(instruction.nodes.front().value); it != std::cend(scopeNodes))
					scopeNodes.erase(it);
				return {};
			};
			functions["clear"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				context.getScope().nodes.clear();
				return {};
			};
			functions["="_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"No node to edit"};
				if (std::empty(instruction.nodes)) [[unlikely]]
					return std::unexpected{"No value to set"};
				scopeNodes.back().value = instruction.nodes.front().value;
				return {};
			};
			functions["exists"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				auto nodeId = String::Token{};
				if (std::empty(instruction.nodes))
				{
					if (std::empty(scopeNodes)) [[unlikely]]
						return std::unexpected{"No node to search"};
					nodeId = scopeNodes.back().value;
				}
				else
					nodeId = instruction.nodes.front().value;
				scopeNodes.emplace_back(context.functions.contains(nodeId));
				return {};
			};
			functions["functionExists"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				auto nodeId = String::Token{};
				if (std::empty(instruction.nodes))
				{
					if (std::empty(scopeNodes)) [[unlikely]]
						return std::unexpected{"No function to search"};
					nodeId = scopeNodes.back().value;
				}
				else
					nodeId = instruction.nodes.front().value;
				auto exists = context.exists(nodeId);
				scopeNodes.emplace_back(exists);
				return {};
			};

			functions["readChar"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (cursor.position >= std::size(cursor.source))
					return std::unexpected{"Out of string"};
				scopeNodes.emplace_back(static_cast<String::Token>(cursor.getCurrent()));
				return {};
			};
			functions["getCursorPosition"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(cursor.source)) [[unlikely]]
					return std::unexpected{"Empty source"};
				if (cursor.position >= std::size(cursor.source)) [[unlikely]]
					return std::unexpected{"End of string"};
				scopeNodes.emplace_back(static_cast<String::Token>(cursor.position));
				return {};
			};
			functions["stepCursorForward"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator&) -> std::expected<void, std::string_view> {
				++cursor.position;
				return {};
			};
			functions["stepCursorBackward"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator&) -> std::expected<void, std::string_view> {
				--cursor.position;
				return {};
			};
			functions["isEndOfString"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				scopeNodes.emplace_back(cursor.position >= std::size(cursor.source));
				return {};
			};
			functions["hash"_token] = [](Cursor& cursor, const ASTNode&, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::size(scopeNodes) < 2) [[unlikely]]
					return std::unexpected{R"(Missing arguments in the "hash" instruction)"};
				const auto length = Container::Vector::popBack(scopeNodes).value;
				const auto startPosition = Container::Vector::popBack(scopeNodes).value;
				if (startPosition + length > std::size(cursor.source)) [[unlikely]]
					return std::unexpected{R"(Out of string)"};
				scopeNodes.emplace_back(String::hash(cursor.source.substr(startPosition, length)));
				return {};
			};

			static constexpr auto unaryOperator = [](auto operation, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"Missing argument"};
				scopeNodes.emplace_back(operation(Container::Vector::popBack(scopeNodes).value));
				return {};
			};

			static constexpr auto binaryOperator = [](auto operation, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				auto lhs = String::Token{};
				auto rhs = String::Token{};
				if (auto rhsNode = instruction.find("rhs"_token); rhsNode != std::cend(instruction.nodes))
				{
					if (std::empty(scopeNodes)) [[unlikely]]
						return std::unexpected{"Missing lhs"};
					lhs = scopeNodes.back().value;
					rhs = rhsNode->nodes.front().value;
				}
				else
				{
					if (std::size(scopeNodes) < 2) [[unlikely]]
						return std::unexpected{"Missing operands"};
					lhs = scopeNodes[std::size(scopeNodes) - 2].value;
					rhs = scopeNodes.back().value;
					if (not instruction.exists("keepRhs"_token))
						scopeNodes.pop_back();
				}
				if (instruction.exists("erase"_token))
					scopeNodes.back().value = operation(lhs, rhs);
				else
					scopeNodes.emplace_back(operation(lhs, rhs));
				return {};
			};

			functions["and"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::logical_and{}, instruction, context); };
			functions["or"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::logical_or{}, instruction, context); };
			functions["not"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) { return unaryOperator(std::logical_not{}, context); };

			functions["=="_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::equal_to{}, instruction, context); };
			functions["!="_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::not_equal_to{}, instruction, context); };
			functions[">"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::greater{}, instruction, context); };
			functions["<"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::less{}, instruction, context); };
			functions[">="_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::greater_equal{}, instruction, context); };
			functions["<="_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::less_equal{}, instruction, context); };

			functions["+"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::plus{}, instruction, context); };
			functions["-"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::minus{}, instruction, context); };
			functions["*"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::multiplies{}, instruction, context); };
			functions["/"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::divides{}, instruction, context); };
			functions["%"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::modulus{}, instruction, context); };

			functions["&"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::bit_and{}, instruction, context); };
			functions["|"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::bit_or{}, instruction, context); };
			functions["^"_token] = [](Cursor&, const ASTNode& instruction, MetaEvaluator& context) { return binaryOperator(std::bit_xor{}, instruction, context); };
			functions["!"_token] = [](Cursor&, const ASTNode&, MetaEvaluator& context) { return unaryOperator(std::bit_not{}, context); };

			static constexpr auto condition = [](auto operation, Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"condition: No value to check"};
				if (operation(scopeNodes.back().value))
				{
					auto lexemes = std::ref(instruction.nodes);
					for (auto instructionPosition = 0uz; not context.exit and instructionPosition < std::size(lexemes.get()); ++instructionPosition)
					{
						const auto& lexeme = lexemes.get()[instructionPosition];
						if (auto result = context(cursor, lexeme); not result) [[unlikely]]
							return result;
						lexemes = std::ref(instruction.nodes);
					}
				}
				return {};
			};

			functions["if"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) { return condition(std::identity{}, cursor, instruction, context); };
			functions["ifNot"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) { return condition(std::logical_not{}, cursor, instruction, context); };

			functions["while"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(instruction.nodes)) [[unlikely]]
					return std::unexpected{"while: No condition to execute"};
				if (auto result = context(cursor, instruction.nodes.front()); not result) [[unlikely]]
					return result;
				if (context.exit)
					return {};
				if (std::empty(scopeNodes)) [[unlikely]]
					return std::unexpected{"while: No value to check"};
				while (Container::Vector::popBack(scopeNodes).value)
				{
					auto lexemes = std::ref(instruction.nodes);
					for (auto instructionPosition = 1uz; instructionPosition < std::size(lexemes.get()); ++instructionPosition)
					{
						const auto& lexeme = lexemes.get()[instructionPosition];
						if (auto result = context(cursor, lexeme); not result) [[unlikely]]
							return result;
						if (context.exit)
							return {};
						lexemes = std::ref(instruction.nodes);
					}
					if (auto result = context(cursor, instruction.nodes.front()); not result) [[unlikely]]
						return result;
					if (context.exit)
						return {};
					if (std::empty(scopeNodes)) [[unlikely]]
						return std::unexpected{"while: No value to check"};
				}
				return {};
			};
			functions["doWhile"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				if (std::empty(instruction.nodes)) [[unlikely]]
					return std::unexpected{"doWhile: No condition to execute"};
				do
				{
					auto lexemes = std::ref(instruction.nodes);
					for (auto instructionPosition = 0uz; instructionPosition < std::size(lexemes.get()); ++instructionPosition)
					{
						const auto& lexeme = lexemes.get()[instructionPosition];
						if (auto result = context(cursor, lexeme); not result) [[unlikely]]
							return result;
						lexemes = std::ref(instruction.nodes);
					}
					if (context.exit)
						return {};
					if (std::empty(scopeNodes)) [[unlikely]]
						return std::unexpected{"doWhile: No value to check"};
				}
				while (Container::Vector::popBack(scopeNodes).value);
				return {};
			};
			functions["optional"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto& scopeNodes = context.getScope().nodes;
				auto lastPosition = cursor.position;
				auto lexemes = std::ref(instruction.nodes);
				for (auto instructionPosition = 0uz; instructionPosition < std::size(lexemes.get()); ++instructionPosition)
				{
					const auto& lexeme = lexemes.get()[instructionPosition];
					if (auto result = context(cursor, lexeme); not result)
					{
						cursor.position = lastPosition;
						scopeNodes.emplace_back(0);
						return {};
					}
					if (context.exit)
						return {};
					lexemes = std::ref(instruction.nodes);
				}
				scopeNodes.emplace_back(1);
				return {};
			};
			functions["alternative"_token] = [](Cursor& cursor, const ASTNode& instruction, MetaEvaluator& context) -> std::expected<void, std::string_view> {
				auto lastPosition = cursor.position;
				auto lexemes = std::ref(instruction.nodes);
				for (auto instructionPosition = 0uz; instructionPosition < std::size(lexemes.get()); ++instructionPosition)
				{
					const auto& lexeme = lexemes.get()[instructionPosition];
					if (auto result = context(cursor, lexeme); not result)
					{
						cursor.position = lastPosition;
						lexemes = std::ref(instruction.nodes);
						continue;
					}
					return {};
				}
				return std::unexpected{"No alternative matched"};
			};

			// clang-format off
			rootAst = {0uz, {
				ASTNode{"main"_token, {
					ASTNode{"call"_token, {ASTNode{"doWhile"_token, {
						ASTNode{"callRun"_token},
						ASTNode{"grammar"_token},
						ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
						ASTNode{"call"_token, {ASTNode{"not"_token}}}
					}}}},
					ASTNode{"callRun"_token}
				}},
				ASTNode{"callRun"_token, {
					ASTNode{"call"_token, {ASTNode{"functionExists"_token, {ASTNode{"run"_token}}}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"run"_token},
						ASTNode{"call"_token, {ASTNode{"return"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}}
				}},
				ASTNode{"grammar"_token, {
					ASTNode{"skipSpaces"_token},
					ASTNode{"call"_token, {ASTNode{"optional"_token, {ASTNode{"treeParser"_token}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}}
				}},
				ASTNode{"treeParser"_token, {
					ASTNode{"parseTreeNode"_token},
					ASTNode{"skipSpaces"_token}
				}},
				ASTNode{"parseTreeNodes"_token, {
					ASTNode{"call"_token, {ASTNode{"doWhile"_token, {
						ASTNode{"call"_token, {ASTNode{"optional"_token, {ASTNode{"parseTreeNode"_token}}}}},
					}}}}
				}},
				ASTNode{"parseTreeNode"_token, {
					ASTNode{"skipSpaces"_token},
					ASTNode{"call"_token, {ASTNode{"alternative"_token, {
						ASTNode{"parseValue"_token},
						ASTNode{"parseToken"_token}
					}}}},
					ASTNode{"call"_token, {ASTNode{"enterInLast"_token}}},
					ASTNode{"call"_token, {ASTNode{"optional"_token, {
						ASTNode{"parseOpeningBrace"_token},
						ASTNode{"parseTreeNodes"_token},
						ASTNode{"parseClosingBrace"_token},
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"leave"_token}}}
				}},
				ASTNode{"isSpace"_token, {
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{' '}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {ASTNode{"call"_token, {ASTNode{"return"_token}}}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\f'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {ASTNode{"call"_token, {ASTNode{"return"_token}}}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\n'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {ASTNode{"call"_token, {ASTNode{"return"_token}}}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\r'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {ASTNode{"call"_token, {ASTNode{"return"_token}}}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\t'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {ASTNode{"call"_token, {ASTNode{"return"_token}}}}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\v'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"return"_token}}}
				}},
				ASTNode{"skipSpaces"_token, {
					ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"return"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"call"_token, {ASTNode{"while"_token, {
						ASTNode{"isSpace"_token},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}},
						ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
						ASTNode{"call"_token, {ASTNode{"if"_token, {
							ASTNode{"call"_token, {ASTNode{"delete"_token}}},
							ASTNode{"call"_token, {ASTNode{"return"_token}}}
						}}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}}
				}},
				ASTNode{"isValueChar"_token, {
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'\''}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"return"_token}}}
				}},
				ASTNode{"parseValue"_token, {
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"isValueChar"_token},
					ASTNode{"call"_token, {ASTNode{"not"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"isValueChar"_token},
					ASTNode{"call"_token, {ASTNode{"not"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}}
				}},
				ASTNode{"isTokenChar"_token, {
					ASTNode{"isSpace"_token},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"not"_token}}},
						ASTNode{"call"_token, {ASTNode{"return"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'{'}}}}},
					ASTNode{"call"_token, {ASTNode{"=="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"not"_token}}},
						ASTNode{"call"_token, {ASTNode{"return"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'}'}}}}},
					ASTNode{"call"_token, {ASTNode{"!="_token}}},
					ASTNode{"call"_token, {ASTNode{"return"_token}}}
				}},
				ASTNode{"countTokenLength"_token, {
					ASTNode{"call"_token, {ASTNode{"new"_token}}},
					ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"call"_token, {ASTNode{"while"_token, {
						ASTNode{"isTokenChar"_token},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"+"_token, {ASTNode{"rhs"_token, {ASTNode{1}}}, ASTNode{"erase"_token}}}}},
						ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}},
						ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
						ASTNode{"call"_token, {ASTNode{"if"_token, {
							ASTNode{"call"_token, {ASTNode{"delete"_token}}},
							ASTNode{"call"_token, {ASTNode{"return"_token}}}
						}}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"readChar"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}}
				}},
				ASTNode{"parseToken"_token, {
					ASTNode{"call"_token, {ASTNode{"getCursorPosition"_token}}},
					ASTNode{"countTokenLength"_token},
					ASTNode{"call"_token, {ASTNode{"=="_token, {ASTNode{"rhs"_token, {ASTNode{0}}}}}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"hash"_token}}}
				}},
				ASTNode{"parseOpeningBrace"_token, {
					ASTNode{"skipSpaces"_token},
					ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'{'}}}}},
					ASTNode{"call"_token, {ASTNode{"!="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}}
				}},
				ASTNode{"parseClosingBrace"_token, {
					ASTNode{"skipSpaces"_token},
					ASTNode{"call"_token, {ASTNode{"isEndOfString"_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"readChar"_token}}},
					ASTNode{"call"_token, {ASTNode{"new"_token, {ASTNode{'}'}}}}},
					ASTNode{"call"_token, {ASTNode{"!="_token}}},
					ASTNode{"call"_token, {ASTNode{"if"_token, {
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"syntaxError"_token}}}
					}}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
					ASTNode{"call"_token, {ASTNode{"delete"_token}}},
						ASTNode{"call"_token, {ASTNode{"stepCursorForward"_token}}}
				}}
			}};
			// clang-format on
		}
	};
}

export module CppUtils.Language.MetaEvaluator;

import std;
import CppUtils.String;
import CppUtils.Language.AST;

export namespace CppUtils::Language
{
	struct MetaEvaluator
	{
		using Cursor = String::Cursor<std::string_view>;

		[[nodiscard]] inline constexpr auto operator()(
			Cursor& cursor,
			const ASTNode& instruction = ASTNode{String::hash("main")})
			-> std::expected<void, std::string_view>
		{
			using namespace String::Literals;

			if (instruction.value == "call"_token)
			{
				if (std::empty(instruction.nodes)) [[unlikely]]
					return std::unexpected{R"(Missing argument in the "call" instruction)"};
				if (auto it = functions.find(instruction.nodes.front().value); it != std::cend(functions))
					return it->second(cursor, instruction.nodes.front(), *this);
				else [[unlikely]]
					return std::unexpected{"Unknown function"};
			}

			auto grammar = [this, instruction]() -> std::reference_wrapper<ASTNode> {
				const auto range = scopes | std::views::reverse;
				auto it = std::ranges::find_if(range, [instruction](const auto scope) -> bool { return scope.get().exists(instruction.value); });
				return it != std::ranges::end(range) ? *it : scopes.front();
			}();
			if (not grammar.get().exists(instruction.value)) [[unlikely]]
				return std::unexpected{"Unknown lexeme"};
			auto lexemes = std::ref(grammar.get()[instruction.value].nodes);
			for (auto instructionPosition = 0uz; not exit and instructionPosition < std::size(lexemes.get()); ++instructionPosition)
			{
				const auto& lexeme = lexemes.get()[instructionPosition];
				if (auto result = operator()(cursor, lexeme); not result) [[unlikely]]
					return result;
				if (not grammar.get().exists(instruction.value)) [[unlikely]]
					return {};
				if (not grammar.get().exists(instruction.value)) [[unlikely]]
					return std::unexpected{"Unknown lexeme"};
				lexemes = std::ref(grammar.get()[instruction.value].nodes);
			}
			exit = false;
			return {};
		}

		[[nodiscard]] inline auto getScope() -> ASTNode&
		{
			return scopes.back().get();
		}

		std::unordered_map<String::Token, std::function<std::expected<void, std::string_view>(Cursor&, const ASTNode&, MetaEvaluator&)>> functions;
		ASTNode rootAst = {0uz, {ASTNode{String::hash("main")}}};
		std::vector<std::reference_wrapper<ASTNode>> scopes = {std::ref(rootAst)};
		bool exit = false;
	};
}

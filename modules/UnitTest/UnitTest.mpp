module;

#include <cstdio>

export module CppUtils.UnitTest;

import std;
import CppUtils.Chrono.Concept;
import CppUtils.ChronoLogger;
import CppUtils.Container;
import CppUtils.Logger;
import CppUtils.Log.Exception;
import CppUtils.Log.Config.UnitTests;
import CppUtils.String;
import CppUtils.Terminal;
import CppUtils.System.Main;

export import CppUtils.UnitTest.DummyObject;

namespace CppUtils::UnitTest
{
	export struct TestSettings final
	{
		bool verbose = true;
		bool detail = true;
		bool chrono = false;
		bool fastAbort = false;
	};

	struct Test final
	{
		std::string name;
		std::function<void(std::stop_token)> function;
		std::chrono::seconds timeout = std::chrono::seconds{10};
	};

	class TestException: public std::runtime_error
	{
	public:
		inline TestException(std::string message):
			std::runtime_error{std::move(message)}
		{}
	};

	class TestRunner final
	{
		using Logger = Logger<"UnitTests">;

	public:
		inline auto addTestSuite(const std::string& name, std::vector<Test> tests) -> void
		{
			for (auto& test : tests)
				test.name = std::format("{}/{}", name, test.name);
			m_testSuites.insert(name, std::move(tests));
		}

		inline auto addTestSuite(const std::string& name, std::vector<std::string> prerequisites, std::vector<Test> tests) -> void
		{
			addTestSuite(name, tests);
			for (const auto& prerequisite : prerequisites)
				m_testSuites.addDependency(name, prerequisite);
		}

		inline auto executeTest(const Test& test, const TestSettings& settings) const -> bool
		{
			if (settings.verbose)
			{
				Logger::emit<"separator">();
				Logger::print<"detail">("{}:", test.name);
			}
			try
			{
				try
				{
					auto chronoLogger = Log::ChronoLogger{[](std::string_view duration) {
						Logger::print<"detail">("Test duration: {}", duration);
					}, settings.verbose and settings.chrono};

					auto promise = std::promise<void>{};
					auto future = promise.get_future();

					auto worker = std::jthread{[promise = std::move(promise), function = test.function](std::stop_token stopToken) mutable {
						try
						{
							function(stopToken);
							promise.set_value();
						}
						catch (...)
						{
							promise.set_exception(std::current_exception());
						}
					}};

					if (future.wait_for(test.timeout) == std::future_status::timeout)
					{
						worker.request_stop();
						worker.detach();
						throw TestException{std::format("Test timed out after {}s", test.timeout.count())};
					}

					future.get();
				}
				catch (const TestException&)
				{
					std::throw_with_nested(std::runtime_error{std::format("The following test didn't pass:\n{}", test.name)});
				}
				catch (const std::exception& exception)
				{
					std::throw_with_nested(std::runtime_error{std::format("An exception occurred during the test:\n{}\n{}", test.name, exception.what())});
				}
			}
			catch (const std::exception& exception)
			{
				logException<Logger>(exception);
				return false;
			}
			if (settings.verbose)
				Logger::print<"success">("Passed");
			return true;
		}

		inline auto executeTests(TestSettings settings) -> int
		{
			auto testSuiteIsSuccess = std::unordered_map<std::string, bool>{};

			const auto nbTests = std::ranges::fold_left(
				std::views::values(m_testSuites.nodes) | std::views::transform([](auto&& node) { return std::ranges::size(node.value); }),
				0uz,
				std::plus{});
			Logger::print<"info">("{} tests found. Execution:", nbTests);

			auto successfulTests = std::vector<std::string>{};
			auto failedTests = std::vector<std::string>{};
			auto skippedTests = std::vector<std::string>{};

			if (auto result = m_testSuites.forEach([&](const auto& name, const auto& tests, const auto& dependencies) -> bool {
				if (std::empty(tests))
				{
					Logger::print<"warning">("No tests found in test suite {}", name);
					testSuiteIsSuccess[name] = true;
					successfulTests.push_back(name);
					return not settings.fastAbort;
				}

				for (const auto& dependency : dependencies)
					if (not testSuiteIsSuccess[dependency])
					{
						Logger::print<"warning">("Skipping test suite {} due to failed prerequisites in test suite {}", name, dependency);
						testSuiteIsSuccess[name] = false;
						skippedTests.push_back(name);
						return not settings.fastAbort;
					}

				auto result = std::ranges::all_of(tests, [&](const auto& test) { return executeTest(test, settings); });
				testSuiteIsSuccess[name] = result;
				(result ? successfulTests : failedTests).push_back(name);
				return result or not settings.fastAbort;
			});
				not result)
				Logger::print<"error">("The tests cannot be run: {}", result.error());

			auto nbSuccess = std::size(successfulTests);
			auto nbFail = std::size(failedTests);
			auto nbSkip = std::size(skippedTests);

			Logger::emit<"separator">();
			Logger::print<"detail">("Test results");
			if (nbFail == 0 and nbSkip == 0)
			{
				Logger::print<"success">("All tests passed successfully");
				return exitSuccess;
			}
			if (nbFail > 0)
				Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Red, "The tests failed:");
			else
				Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Yellow, "Some tests were skipped:");

			if (nbSuccess > 0)
				Logger::print<"success">("- {} successful tests", nbSuccess);
			if (nbSuccess == 0)
				Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Red, "- 0 successful tests");
			
			if (nbFail > 0)
			{
				Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Red, std::format("- {} failed tests", nbFail));
				for (const auto& failedTest : failedTests)
					Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Red, std::format("  - {}", failedTest));
			}

			if (nbSkip > 0)
			{
				Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Yellow, std::format("- {} skipped tests (due to failed dependencies)", nbSkip));
				for (const auto& skippedTest : skippedTests)
					Logger::emit<"color">(Terminal::TextColor::TextColorEnum::Yellow, std::format("  - {}", skippedTest));
			}

			Logger::waitUntilFinished();
			return nbFail == 0 ? exitSuccess : exitFailure;
		}

	private:
		Container::DependencyGraph<std::string, std::vector<Test>> m_testSuites;
	};

	inline /* constinit */ auto testRunner = TestRunner{};

	export struct TestSuite final
	{
		using Logger = Logger<"UnitTests">;

		inline explicit TestSuite(const std::string& name, std::vector<std::string> prerequisites, std::function<void(TestSuite&)> function)
		{
			function(*this);
			testRunner.addTestSuite(name, prerequisites, std::move(tests));
		}

		inline explicit TestSuite(std::string name, std::function<void(TestSuite&)> function)
		{
			function(*this);
			testRunner.addTestSuite(name, std::move(tests));
		}

		inline auto addTest(std::string name, std::function<void(std::stop_token)> function, std::chrono::seconds timeout = std::chrono::seconds{10}) -> void
		{
			tests.emplace_back(std::move(name), std::move(function), timeout);
		}

		inline auto addTest(std::string name, std::function<void()> function, std::chrono::seconds timeout = std::chrono::seconds{10}) -> void
		{
			tests.emplace_back(std::move(name), [function = std::move(function)](std::stop_token) { function(); }, timeout);
		}

		// Todo C++23: std::stacktrace stacktrace = std::current_stacktrace()
		inline auto expect(bool condition, std::source_location sourceLocation = std::source_location::current()) -> void
		{
			if (not condition) [[unlikely]]
				throw TestException{std::format("In {}\nAt line {}, column {}\nIn expect(condition)",
					sourceLocation.file_name(),
					sourceLocation.line(),
					sourceLocation.column())};
		}

		inline auto expectEqual(const auto& lhs, const auto& rhs, std::source_location sourceLocation = std::source_location::current()) -> void
		{
			if (lhs != rhs) [[unlikely]]
				throw TestException{std::format("In {}\nAt line {}, column {}\nIn expectEqual(lhs, rhs)\nwith lhs:\n{}\nand rhs:\n{}",
					sourceLocation.file_name(),
					sourceLocation.line(),
					sourceLocation.column(),
					String::formatValue(lhs),
					String::formatValue(rhs))};
		}

		template<class ExceptionType>
		inline auto expectThrow(auto&& function, std::source_location sourceLocation = std::source_location::current()) -> void
		{
			try
			{
				function();
				throw TestException{std::format("In {}\nAt line {}, column {}\nExpected throw of type {}, but no exception was thrown.",
					sourceLocation.file_name(),
					sourceLocation.line(),
					sourceLocation.column(),
					typeid(ExceptionType).name())};
			}
			catch (const ExceptionType&)
			{
				Logger::emit<"success">("Expected exception caught.");
			}
			catch (const std::exception& exception)
			{
				throw TestException{std::format("In {}\nAt line {}, column {}\nExpected throw of type {}, but caught different exception: {}",
					sourceLocation.file_name(),
					sourceLocation.line(),
					sourceLocation.column(),
					typeid(ExceptionType).name(),
					exception.what())};
			}
		}

		inline auto expectNoThrow(auto&& function, std::source_location sourceLocation = std::source_location::current()) -> void
		{
			try
			{
				function();
			}
			catch (const std::exception& exception)
			{
				throw TestException{std::format("In {}\nAt line {}, column {}\nExpected no throw, but an exception was thrown: {}",
					sourceLocation.file_name(),
					sourceLocation.line(),
					sourceLocation.column(),
					exception.what())};
			}
		}

		std::vector<Test> tests;
	};

	export inline auto executeTests(TestSettings settings) -> int
	{
		return testRunner.executeTests(std::move(settings));
	}
}

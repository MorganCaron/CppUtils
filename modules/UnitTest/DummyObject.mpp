export module CppUtils.UnitTest.DummyObject;

import std;

export namespace CppUtils::UnitTest
{
	class DummyObject
	{
	public:
		inline DummyObject(std::function<void(std::string_view)> callback, std::string name, std::size_t indentationLevel = 0):
			m_callback{std::move(callback)},
			m_name{std::move(name)},
			m_indentationLevel{indentationLevel}
		{
			m_callback(std::format("{}{}()", std::string(m_indentationLevel, '\t'), m_name));
		}

		[[nodiscard]] inline auto getCopyCount() const -> std::size_t
		{
			return m_copyCount;
		}

		[[nodiscard]] inline auto getMoveCount() const -> std::size_t
		{
			return m_moveCount;
		}

		virtual ~DummyObject()
		{
			m_callback(std::format("{}~{}()", std::string(m_indentationLevel, '\t'), m_name));
		}

		inline DummyObject(const DummyObject& other):
			m_callback{other.m_callback},
			m_name{other.m_name},
			m_indentationLevel{other.m_indentationLevel},
			m_copyCount{other.m_copyCount.load() + 1},
			m_moveCount{other.m_moveCount.load()}
		{
			m_callback(std::format("{}{}(const {}&)", std::string(m_indentationLevel, '\t'), m_name, m_name));
		}

		inline DummyObject(DummyObject&& other) noexcept:
			m_callback{other.m_callback},
			m_name{std::move(other.m_name)},
			m_indentationLevel{other.m_indentationLevel},
			m_copyCount{other.m_copyCount.load()},
			m_moveCount{other.m_moveCount.load() + 1}
		{
			other.m_name = "[invalid object]";
			m_callback(std::format("{}{}({}&&)", std::string(m_indentationLevel, '\t'), m_name, m_name));
		}

		inline auto operator=(const DummyObject& rhs) -> DummyObject&
		{
			m_callback = rhs.m_callback;
			m_name = rhs.m_name;
			m_indentationLevel = rhs.m_indentationLevel;
			m_copyCount.store(rhs.m_copyCount.load() + 1);
			m_moveCount.store(rhs.m_moveCount.load());
			m_callback(std::format("{}{}::operator=(const {}&)", std::string(m_indentationLevel, '\t'), m_name, m_name));
			return *this;
		}

		inline auto operator=(DummyObject&& rhs) noexcept -> DummyObject&
		{
			m_callback = rhs.m_callback;
			m_name = std::move(rhs.m_name);
			m_indentationLevel = rhs.m_indentationLevel;
			m_copyCount.store(rhs.m_copyCount.load());
			m_moveCount.store(rhs.m_moveCount.load() + 1);
			rhs.m_name = "[invalid object]";
			m_callback(std::format("{}{}::operator=({}&&)", std::string(m_indentationLevel, '\t'), m_name, m_name));
			return *this;
		}

	private:
		std::function<void(std::string_view)> m_callback;
		std::string m_name;
		std::size_t m_indentationLevel;
		std::atomic_size_t m_copyCount = 0;
		std::atomic_size_t m_moveCount = 0;
	};
}

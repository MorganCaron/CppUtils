export module CppUtils.Type.Mapping;

import std;

export namespace CppUtils::Type
{
	template<auto Lhs, auto... Rhs>
	struct Pair final
	{
		static constexpr auto lhs = Lhs;
		static constexpr auto rhs = std::tuple{Rhs...};
	};

	template<class... Pairs>
	struct Mapping final
	{
		using Values = std::tuple<Pairs...>;

		Mapping() = delete;

		template<auto Lhs>
		[[nodiscard]] static inline consteval auto toRhs() noexcept -> auto
		{
			if constexpr (sizeof...(Pairs) == 0)
				static_assert([] { return false; }(), "Lhs not found");
			else
				return []<auto Target, class First, class... Rest>(this auto&& self) consteval {
					if constexpr (First::lhs == Target)
						return First::rhs;
					else if constexpr (sizeof...(Rest) == 0)
						static_assert([] { return false; }(), "Lhs not found");
					else
						return self.template operator()<Target, Rest...>();
				}.template operator()<Lhs, Pairs...>();
		}

		template<auto Rhs>
		[[nodiscard]] static inline consteval auto toLhs() noexcept -> auto
		{
			if constexpr (sizeof...(Pairs) == 0)
				static_assert([] { return false; }(), "Rhs not found");
			else
				return []<auto Target, class First, class... Rest>(this auto&& self) consteval {
					if constexpr (contains<Target>(First::rhs))
						return First::lhs;
					else if constexpr (sizeof...(Rest) == 0)
						static_assert([] { return false; }(), "Rhs not found");
					else
						return self.template operator()<Target, Rest...>();
				}.template operator()<Rhs, Pairs...>();
		}

		template<auto Lhs>
		[[nodiscard]] static inline consteval auto toSingleRhs() noexcept -> auto
		{
			constexpr auto tuple = toRhs<Lhs>();
			static_assert(std::tuple_size_v<decltype(tuple)> == 1);
			return std::get<0>(tuple);
		}

		template<auto Lhs>
		[[nodiscard]] static inline consteval auto containsLhs() noexcept -> bool
		{
			return ((Pairs::lhs == Lhs) or ...);
		}

		template<auto Lhs>
		[[nodiscard]] static inline consteval auto hasSingleRhs() noexcept -> bool
		{
			if constexpr (containsLhs<Lhs>())
				return std::tuple_size_v<decltype(toRhs<Lhs>())> == 1;
			else
				return false;
		}

		template<auto Value, class Tuple>
		[[nodiscard]] static inline consteval auto contains(const Tuple& tuple) noexcept -> bool
		{
			return []<std::size_t... I>(const Tuple& tuple, std::index_sequence<I...>) constexpr noexcept -> bool {
				return ((std::get<I>(tuple) == Value) or ...);
			}(tuple, std::make_index_sequence<std::tuple_size_v<Tuple>>{});
		}
	};
}

export module CppUtils.Thread.ScheduledEventDispatcher;

import std;
import CppUtils.Chrono.Concept;
import CppUtils.Execution.EventDispatcher;
import CppUtils.String.Hash;
import CppUtils.Thread.Scheduler;

export namespace CppUtils::Thread
{
	class ScheduledEventDispatcher final
	{
	public:
		using Clock = std::chrono::steady_clock;
		using TimePoint = Clock::time_point;

		explicit ScheduledEventDispatcher(
			Scheduler::Clock::duration step = std::chrono::milliseconds(10),
			std::size_t numberThreads = std::thread::hardware_concurrency(),
			std::function<void(std::exception_ptr)> onError = nullptr,
			std::function<void()> finally = nullptr):
			m_scheduler{step, numberThreads, std::move(onError), std::move(finally)}
		{}

		template<String::Hasher eventName = String::Hash{}>
		inline auto subscribe(auto&& function) -> void
		{
			m_eventDispatcher.subscribe<eventName>(std::forward<decltype(function)>(function));
		}

		template<String::Hasher eventName = String::Hash{}, class... Args, Chrono::Duration Delay = std::chrono::milliseconds>
		inline auto emit(Delay delay, Args&&... args) -> void
		{
			m_scheduler.schedule([this, payload = std::make_tuple(std::forward<Args>(args)...)] {
				std::apply([this](const auto&... args) {
					m_eventDispatcher.emit<eventName>(args...);
				}, payload);
			}, delay);
		}

		template<String::Hasher eventName = String::Hash{}, class... Args>
		inline auto emit(TimePoint when, Args&&... args) -> void
		{
			m_scheduler.schedule([this, payload = std::make_tuple(std::forward<Args>(args)...)] {
				std::apply([this](const auto&... args) {
					m_eventDispatcher.emit<eventName>(args...);
				}, payload);
			}, when);
		}

		template<String::Hasher eventName = String::Hash{}, class... Args>
		inline auto emit(Args&&... args) -> void
		{
			emit<eventName>(std::chrono::milliseconds{0}, std::forward<Args>(args)...);
		}

		inline auto waitUntilFinished() -> void
		{
			m_scheduler.waitUntilFinished();
		}

	private:
		Scheduler m_scheduler;
		Execution::EventDispatcher m_eventDispatcher;
	};
}

export module CppUtils.Thread.UniqueLocker;

import std;

export namespace CppUtils::Thread
{
	template<class T, class Mutex = std::mutex>
	class Accessor final
	{
	public:
		inline explicit Accessor(Mutex& mutex, T& value):
			m_lockGuard{mutex},
			m_value{std::ref(value)}
		{}

		template<class Self>
		[[nodiscard]] inline auto value(this Self& self) noexcept -> decltype(auto)
		{
			return self.m_value.get();
		}

		template<class Self>
		[[nodiscard]] inline auto operator->(this Self& self) noexcept -> decltype(auto)
		{
			return std::addressof(self.value());
		}

		[[nodiscard]] inline auto getLockGuard() & noexcept -> auto&
		{
			return m_lockGuard;
		}

	private:
		mutable std::unique_lock<Mutex> m_lockGuard;
		std::reference_wrapper<T> m_value;
	};

	template<class T, class Mutex>
	class Accessor<const T, Mutex> final
	{
	public:
		inline explicit Accessor(Mutex& mutex, const T& value):
			m_lockGuard{mutex},
			m_value{std::cref(value)}
		{}

		template<class Self>
		[[nodiscard]] inline auto value(this Self& self) noexcept -> decltype(auto)
		{
			return self.m_value.get();
		}

		template<class Self>
		[[nodiscard]] inline auto operator->(this Self& self) noexcept -> decltype(auto)
		{
			return std::addressof(self.value());
		}

		[[nodiscard]] inline auto getLockGuard() & noexcept -> auto&
		{
			return m_lockGuard;
		}

	private:
		std::unique_lock<Mutex> m_lockGuard;
		std::reference_wrapper<const T> m_value;
	};

	template<class Mutex, class T>
	Accessor(Mutex&, T&) -> Accessor<T, Mutex>;

	template<class T>
	class UniqueLocker final
	{
	public:
		inline explicit UniqueLocker(auto&&... args):
			m_value{std::forward<decltype(args)>(args)...}
		{}

		[[nodiscard]] inline auto access() & -> Accessor<T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

		inline auto access() const& -> Accessor<const T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

		inline auto access() const&& -> Accessor<const T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

	private:
		mutable std::mutex m_mutex;
		T m_value;

		template<class... Lockers>
		friend struct MultipleAccessor;
	};

	template<class T>
	UniqueLocker(T) -> UniqueLocker<T>;

	template<class... Lockers>
	struct MultipleAccessor final
	{
		MultipleAccessor(Lockers&... lockers):
			m_lockGuard{lockers.m_mutex...},
			values{std::tie(lockers.m_value...)}
		{}

	private:
		std::scoped_lock<decltype(std::declval<Lockers>().m_mutex)...> m_lockGuard;

	public:
		std::tuple<decltype(std::declval<Lockers>().m_value)&...> values;
	};
}

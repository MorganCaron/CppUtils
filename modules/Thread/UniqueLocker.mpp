export module CppUtils.Thread.UniqueLocker;

import std;

export namespace CppUtils::Thread
{
	/*
		Classe RAII fournissant un accès unique à une valeur (en lecture et écriture).
		Cette classe ne contient pas la valeur, seulement une référence vers celle-ci.
	*/
	template<class T, class Mutex = std::mutex>
	class Accessor final
	{
	public:
		inline explicit Accessor(Mutex& mutex, T& value):
			m_lockGuard{mutex},
			m_value{std::ref(value)}
		{}

		template<class Self>
		[[nodiscard]] inline auto value(this Self& self) noexcept -> decltype(auto)
		{
			return self.m_value.get();
		}

		template<class Self>
		[[nodiscard]] inline auto operator->(this Self& self) noexcept -> decltype(auto)
		{
			return std::addressof(self.value());
		}

		[[nodiscard]] inline auto getLockGuard() & noexcept -> auto&
		{
			return m_lockGuard;
		}

	private:
		mutable std::unique_lock<Mutex> m_lockGuard;
		std::reference_wrapper<T> m_value;
	};

	/*
		Classe RAII fournissant un accès unique à une valeur (en lecture seule).
		Cette classe ne contient pas la valeur, seulement une référence vers celle-ci.
	*/
	template<class T, class Mutex>
	class Accessor<const T, Mutex> final
	{
	public:
		inline explicit Accessor(Mutex& mutex, const T& value):
			m_lockGuard{mutex},
			m_value{std::cref(value)}
		{}

		template<class Self>
		[[nodiscard]] inline auto value(this Self& self) noexcept -> decltype(auto)
		{
			return self.m_value.get();
		}

		template<class Self>
		[[nodiscard]] inline auto operator->(this Self& self) noexcept -> decltype(auto)
		{
			return std::addressof(self.value());
		}

		[[nodiscard]] inline auto getLockGuard() & noexcept -> auto&
		{
			return m_lockGuard;
		}

	private:
		std::unique_lock<Mutex> m_lockGuard;
		std::reference_wrapper<const T> m_value;
	};

	template<class Mutex, class T>
	Accessor(Mutex&, T&) -> Accessor<T, Mutex>;

	/*
		Classe conçue pour encapsuler une ressource avec son mutex, garantissant que l'accès à la ressource passe obligatoirement par un Accessor qui verrouille le mutex (principe de "Monitor Object").

		En plus de la protection RAII apportée par std::unique_lock, permettant de libérer le mutex si une exception survient dans le scope du verrou,
		cette approche permet à un getter de retourner la valeur protégée en l'accompagnant de son verrouillage (contenus dans un Accessor), assurant ainsi que la ressource est toujours accédée de manière sécurisée.

		Cela apporte une sécurité accrue en empêchant structurellement les accès non verrouillés et rend l'intention explicite sur le caractère partagé de l'objet.
	*/
	template<class T>
	class UniqueLocker final
	{
	public:
		inline explicit UniqueLocker(auto&&... args):
			m_value{std::forward<decltype(args)>(args)...}
		{}

		[[nodiscard]] inline auto access() & -> Accessor<T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

		inline auto access() const& -> Accessor<const T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

		inline auto access() const&& -> Accessor<const T, std::mutex>
		{
			return Accessor{m_mutex, m_value};
		}

	private:
		mutable std::mutex m_mutex;
		T m_value;

		template<class... Lockers>
		friend struct MultipleAccessor;
	};

	template<class T>
	UniqueLocker(T) -> UniqueLocker<T>;

	/*
		Structure RAII permettant d'accéder simultanément à plusieurs ressources de manière sécurisée.
		Elle verrouille tous les mutex associés de façon à prévenir les deadlocks.
	*/
	template<class... Lockers>
	struct MultipleAccessor final
	{
		MultipleAccessor(Lockers&... lockers):
			m_lockGuard{lockers.m_mutex...},
			values{std::tie(lockers.m_value...)}
		{}

	private:
		std::scoped_lock<decltype(std::declval<Lockers>().m_mutex)...> m_lockGuard;

	public:
		std::tuple<decltype(std::declval<Lockers>().m_value)&...> values;
	};
}

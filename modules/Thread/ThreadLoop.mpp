module;

#include <cstdio>

export module CppUtils.Thread.ThreadLoop;

import std;

export namespace CppUtils::Thread
{
	class ThreadLoop final
	{
	public:
		inline ThreadLoop() = delete;

		inline explicit ThreadLoop(std::function<void()> function,
			std::function<void()> interruptFunction = nullptr,
			std::function<void(std::exception_ptr)> onError = nullptr) noexcept:
			m_function{std::move(function)},
			m_interruptFunction{std::move(interruptFunction)},
			m_onError{std::move(onError)}
		{}

		inline ThreadLoop(const ThreadLoop&) = delete;
		inline auto operator=(const ThreadLoop&) -> ThreadLoop& = delete;

		inline ThreadLoop(ThreadLoop&& other) noexcept
		{
			auto lockGuard = std::unique_lock{other.m_mutex};
			m_function = std::move(other.m_function);
			m_interruptFunction = std::move(other.m_interruptFunction);
			m_onError = std::move(other.m_onError);
			m_thread = std::move(other.m_thread);
		}

		inline auto operator=(ThreadLoop&& other) noexcept -> ThreadLoop&
		{
			if (this == std::addressof(other))
				return *this;
			auto lockGuard = std::scoped_lock{m_mutex, other.m_mutex};
			m_function = std::move(other.m_function);
			m_interruptFunction = std::move(other.m_interruptFunction);
			m_onError = std::move(other.m_onError);
			m_thread = std::move(other.m_thread);
			return *this;
		}

		inline ~ThreadLoop() noexcept
		{
			stop();
		}

		[[nodiscard]] inline auto isRunning() const noexcept -> bool
		{
			auto lockGuard = std::unique_lock{m_mutex};
			return m_thread.joinable();
		}

		inline auto setInterruptFunction(std::function<void()> interruptFunction) noexcept -> void
		{
			auto lockGuard = std::unique_lock{m_mutex};
			m_interruptFunction = std::move(interruptFunction);
		}

		inline auto setOnError(std::function<void(std::exception_ptr)> onError) noexcept -> void
		{
			auto lockGuard = std::unique_lock{m_mutex};
			m_onError = std::move(onError);
		}

		inline auto start() -> void
		{
			auto lockGuard = std::unique_lock{m_mutex};
			if (m_thread.joinable())
				return;

			m_thread = std::jthread{[function = m_function, interruptFunction = m_interruptFunction, onError = m_onError](std::stop_token stopToken) mutable -> void {
				while (not stopToken.stop_requested())
				{
					try
					{
						if (function)
							function();
					}
					catch (...)
					{
						if (onError)
						{
							try
							{
								onError(std::current_exception());
							}
							catch (const std::exception& exception)
							{
								std::println(stderr, "ThreadLoop: onError threw an exception: {}", exception.what());
							}
							catch (...)
							{
								std::println(stderr, "ThreadLoop: onError threw a non-std exception");
							}
						}
						else
						{
							std::println(stderr, "ThreadLoop: Unhandled exception");
						}
					}
				}
			}};
		}

		inline auto isStopRequested() const -> bool
		{
			return m_thread.get_stop_token().stop_requested();
		}

		inline auto requestStop() -> void
		{
			auto lockGuard = std::unique_lock{m_mutex};
			if (not m_thread.joinable() or m_thread.get_stop_token().stop_requested())
				return;
			m_thread.request_stop();
		}

		inline auto stop() noexcept -> void
		{
			try
			{
				auto interruptFunction = std::function<void()>{};
				{
					auto lockGuard = std::unique_lock{m_mutex};
					if (not m_thread.joinable() or m_thread.get_stop_token().stop_requested())
						return;
					m_thread.request_stop();
					interruptFunction = m_interruptFunction;
				}

				if (interruptFunction)
				{
					try
					{
						interruptFunction();
					}
					catch (...)
					{
						std::println(stderr, "ThreadLoop: interruptFunction threw during stop");
					}
				}
				if (m_thread.joinable())
					m_thread.join();
			}
			catch (const std::exception& exception)
			{
				std::println(stderr, "Exception in ThreadLoop::stop(): {}", exception.what());
			}
			catch (...)
			{
				std::println(stderr, "Unknown exception in ThreadLoop::stop()");
			}
		}

	private:
		mutable std::mutex m_mutex;
		std::function<void()> m_function;
		std::function<void()> m_interruptFunction;
		std::function<void(std::exception_ptr)> m_onError;
		std::jthread m_thread;
	};
}

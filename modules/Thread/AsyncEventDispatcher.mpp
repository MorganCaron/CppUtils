export module CppUtils.Thread.AsyncEventDispatcher;

import std;
import CppUtils.Execution.EventDispatcher;
import CppUtils.String.Hash;
import CppUtils.Thread.ThreadPool;

export namespace CppUtils::Thread
{
	class AsyncEventDispatcher final
	{
	public:
		explicit AsyncEventDispatcher(
			std::size_t numberThreads = std::max(1uz, static_cast<std::size_t>(std::thread::hardware_concurrency())),
			std::function<void(std::exception_ptr)> onError = nullptr,
			std::function<void()> finally = nullptr):
			m_threadPool{numberThreads, std::move(onError), std::move(finally)}
		{}

		template<String::Hasher eventName = String::Hash{}, class... Args>
		inline auto emit(const Args&... args) -> void
		{
			emit(static_cast<String::Hash>(eventName), args...);
		}

		template<class... Args>
		inline auto emit(String::Hash eventName, Args&&... args) -> void
		{
			m_threadPool.call([this, eventName, payload = std::make_tuple(std::forward<Args>(args)...)]() mutable {
				std::apply([this, eventName](auto&&... args) {
					m_eventDispatcher.emit(eventName, std::forward<decltype(args)>(args)...);
				}, std::move(payload));
			});
		}

		template<String::Hasher eventName = String::Hash{}>
		inline auto subscribe(auto&& function) -> void
		{
			m_eventDispatcher.subscribe<eventName>(std::forward<decltype(function)>(function));
		}

		inline auto waitUntilFinished() -> void
		{
			m_threadPool.waitUntilFinished();
		}

	private:
		ThreadPool m_threadPool;
		Execution::EventDispatcher m_eventDispatcher;
	};
}

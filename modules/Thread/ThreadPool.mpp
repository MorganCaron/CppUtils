export module CppUtils.Thread.ThreadPool;

import std;
import CppUtils.Execution.ScopeGuard;
import CppUtils.Logger;
import CppUtils.Thread.ThreadLoop;
import CppUtils.Thread.UniqueLocker;

export namespace CppUtils::Thread
{
	class ThreadPool final
	{
		using Logger = Logger<"CppUtils">;
		using Task = std::function<void()>;

	public:
		explicit inline ThreadPool(
			std::size_t numberThreads = std::max(1uz, static_cast<std::size_t>(std::thread::hardware_concurrency())),
			std::function<void(std::exception_ptr)> onError = nullptr,
			std::function<void()> finally = nullptr):
			m_numberThreads{numberThreads},
			m_onError{std::move(onError)},
			m_finally{std::move(finally)}
		{
			m_workers.reserve(m_numberThreads);
			for (auto i = 0uz; i < m_numberThreads; ++i)
				m_workers.emplace_back(
							 [this] { workerThread(); },
							 [this] { m_startWorkingCondition.notify_all(); },
							 [this](std::exception_ptr exceptionPointer) { handleError(exceptionPointer); })
					.start();
		}

		inline ThreadPool(const ThreadPool&) = delete;
		inline ThreadPool& operator=(const ThreadPool&) = delete;
		inline ThreadPool(ThreadPool&&) = delete;
		inline ThreadPool& operator=(ThreadPool&&) = delete;

		inline ~ThreadPool()
		{
			m_stopRequested = true;
			for (auto& worker : m_workers)
				worker.requestStop();
			m_startWorkingCondition.notify_all();
			for (auto& worker : m_workers)
				worker.stop();
		}

		inline auto call(auto&& function) -> std::future<std::invoke_result_t<std::decay_t<decltype(function)>>>
		{
			using ReturnType = std::invoke_result_t<std::decay_t<decltype(function)>>;
			auto task = std::make_shared<std::packaged_task<ReturnType()>>([this, function = std::forward<decltype(function)>(function)]() mutable {
				auto _ = Execution::ScopeGuard{m_finally};
				try
				{
					std::invoke(function);
				}
				catch (...)
				{
					handleError(std::current_exception());
					throw;
				}
			});
			auto future = task->get_future();
			{
				auto tasksQueueAccessor = m_tasksQueue.access();
				tasksQueueAccessor->emplace([task = std::move(task)] { std::invoke(*task); });
			}
			m_startWorkingCondition.notify_one();
			return future;
		}

		inline auto waitUntilFinished() -> void
		{
			if (auto lockGuard = std::unique_lock{m_waitingMutex};
				m_activeWorkers != 0 or not isTasksQueueEmpty())
				m_waitUntilFinishedCondition.wait(lockGuard, [this] {
					return m_activeWorkers == 0 and isTasksQueueEmpty();
				});
		}

		inline auto setOnError(std::function<void(std::exception_ptr)> onError) noexcept -> void
		{
			auto lockGuard = std::unique_lock{m_onErrorMutex};
			m_onError = std::move(onError);
		}

	private:
		[[nodiscard]] inline auto isTasksQueueEmpty() const -> bool
		{
			auto tasksQueueAccessor = m_tasksQueue.access();
			return std::empty(tasksQueueAccessor.value());
		}

		inline auto workerThread() -> void
		{
			auto task = Task{};

			{
				auto tasksQueueAccessor = m_tasksQueue.access();
				m_startWorkingCondition.wait(tasksQueueAccessor.getLockGuard(), [this, &tasksQueueAccessor] {
					return not std::empty(tasksQueueAccessor.value()) or m_stopRequested.load(std::memory_order_relaxed);
				});

				if (std::empty(tasksQueueAccessor.value()))
					return;

				task = std::move(tasksQueueAccessor->front());
				tasksQueueAccessor->pop();
			}

			m_activeWorkers.fetch_add(1, std::memory_order_relaxed);
			task();
			m_activeWorkers.fetch_sub(1, std::memory_order_relaxed);

			if (m_activeWorkers.load(std::memory_order_relaxed) == 0 and isTasksQueueEmpty())
			{
				auto lockGuard = std::lock_guard{m_waitingMutex};
				m_waitUntilFinishedCondition.notify_all();
			}
		}

		inline auto handleError(std::exception_ptr exceptionPointer) const noexcept -> void
		{
			if (auto lockGuard = std::shared_lock{m_onErrorMutex}; m_onError)
			{
				try
				{
					m_onError(exceptionPointer);
				}
				catch (const std::exception& exception)
				{
					Logger::print<"error">("ThreadPool: onError threw an exception: {}", exception.what());
				}
				catch (...)
				{
					Logger::print<"error">("ThreadPool: onError threw a non-std exception");
				}
			}
		}

	private:
		std::size_t m_numberThreads;
		std::atomic_size_t m_activeWorkers = 0;

		std::condition_variable m_startWorkingCondition;
		std::vector<ThreadLoop> m_workers;
		UniqueLocker<std::queue<Task>> m_tasksQueue;

		std::mutex m_waitingMutex;
		std::condition_variable m_waitUntilFinishedCondition;

		mutable std::shared_mutex m_onErrorMutex;
		std::function<void(std::exception_ptr)> m_onError;
		std::atomic<bool> m_stopRequested = false;

		std::function<void()> m_finally;
	};
}

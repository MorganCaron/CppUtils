module;

#include <cassert>

export module CppUtils.Container.Vec2;

import std;

export namespace CppUtils::Container
{
	template<class T>
	requires (std::is_arithmetic_v<T>)
	struct Vec2 final
	{
		inline constexpr Vec2() = default;

		template<std::convertible_to<T>... Args>
		requires (sizeof...(Args) == 2)
		inline constexpr Vec2(Args&&... args):
			m_values{static_cast<T>(args)...}
		{}

		[[nodiscard]] inline constexpr auto operator[](this auto&& self, std::size_t axis) noexcept -> decltype(auto)
		{
			assert(axis < 2);
			return self.m_values[axis];
		}

		[[nodiscard]] inline constexpr auto x(this auto&& self) noexcept -> decltype(auto) { return self[0]; }
		[[nodiscard]] inline constexpr auto y(this auto&& self) noexcept -> decltype(auto) { return self[1]; }
		[[nodiscard]] inline constexpr auto width(this auto&& self) noexcept -> decltype(auto) { return self[0]; }
		[[nodiscard]] inline constexpr auto height(this auto&& self) noexcept -> decltype(auto) { return self[1]; }

		[[nodiscard]] friend inline constexpr auto operator==(const Vec2& lhs, const Vec2& rhs) noexcept -> bool
		{
			return lhs.m_values == rhs.m_values;
		}

		inline constexpr auto apply(this auto&& self, auto&& function) noexcept -> decltype(auto)
		{
			for (const auto axis : {0uz, 1uz})
				function(axis);
			return self;
		}

		template<class U>
		inline constexpr auto operator+=(this auto&& self, const Vec2<U>& rhs) noexcept -> decltype(self)
		{
			return self.apply([&](std::size_t axis) { self.m_values[axis] += static_cast<T>(rhs[axis]); });
		}

		template<class U>
		inline constexpr auto operator-=(this auto&& self, const Vec2<U>& rhs) noexcept -> decltype(self)
		{
			return self.apply([&](std::size_t axis) { self.m_values[axis] -= static_cast<T>(rhs[axis]); });
		}

		inline constexpr auto operator*=(this auto&& self, auto value) noexcept -> decltype(self)
		{
			return self.apply([&](std::size_t axis) { self.m_values[axis] = static_cast<T>(self.m_values[axis] * value); });
		}

		inline constexpr auto operator/=(this auto&& self, auto value) noexcept -> decltype(self)
		{
			return self.apply([&](std::size_t axis) { self.m_values[axis] = static_cast<T>(self.m_values[axis] / value); });
		}

		std::array<T, 2> m_values;
	};

	template<class T>
	Vec2(T, T) -> Vec2<T>;

	template<class T, class U>
	[[nodiscard]] inline constexpr auto operator+(const Vec2<T>& lhs, const Vec2<U>& rhs) noexcept
	{
		using Common = std::common_type_t<T, U>;
		return Vec2<Common>{
			static_cast<Common>(lhs.x()) + static_cast<Common>(rhs.x()),
			static_cast<Common>(lhs.y()) + static_cast<Common>(rhs.y())};
	}

	template<class T, class U>
	[[nodiscard]] inline constexpr auto operator-(const Vec2<T>& lhs, const Vec2<U>& rhs) noexcept
	{
		using Common = std::common_type_t<T, U>;
		return Vec2<Common>{
			static_cast<Common>(lhs.x()) - static_cast<Common>(rhs.x()),
			static_cast<Common>(lhs.y()) - static_cast<Common>(rhs.y())};
	}

	template<class T>
	[[nodiscard]] inline constexpr auto operator*(const Vec2<T>& lhs, auto value) noexcept
	{
		using Common = std::common_type_t<T, decltype(value)>;
		return Vec2<Common>{
			static_cast<Common>(lhs.x()) * static_cast<Common>(value),
			static_cast<Common>(lhs.y()) * static_cast<Common>(value)};
	}

	template<class T>
	[[nodiscard]] inline constexpr auto operator*(auto value, const Vec2<T>& rhs) noexcept
	{
		using Common = std::common_type_t<T, decltype(value)>;
		return Vec2<Common>{
			static_cast<Common>(value) * static_cast<Common>(rhs.x()),
			static_cast<Common>(value) * static_cast<Common>(rhs.y())};
	}

	template<class T>
	[[nodiscard]] inline constexpr auto operator/(const Vec2<T>& lhs, auto value) noexcept
	{
		using Common = std::common_type_t<T, decltype(value)>;
		return Vec2<Common>{
			static_cast<Common>(lhs.x()) / static_cast<Common>(value),
			static_cast<Common>(lhs.y()) / static_cast<Common>(value)};
	}
}

export namespace std
{
	template<class T, class CharT>
	struct formatter<CppUtils::Container::Vec2<T>, CharT>
	{
		formatter<T, CharT> m_formatter;

		inline constexpr auto parse(auto& context)
		{
			return m_formatter.parse(context);
		}

		inline auto format(const CppUtils::Container::Vec2<T>& vec, auto& context) const
		{
			auto out = context.out();
			out = std::format_to(out, "(");
			context.advance_to(out);
			out = m_formatter.format(vec.x(), context);
			out = std::format_to(out, ", ");
			context.advance_to(out);
			out = m_formatter.format(vec.y(), context);
			return std::format_to(out, ")");
		}
	};
}

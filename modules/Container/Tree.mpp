export module CppUtils.Container.Tree;

import std;
import CppUtils.Type;

export namespace CppUtils::Container
{
	template<class T>
	struct Tree final
	{
		using ValueType = T;

		struct Node final
		{
			using ValueType = T;

			ValueType value;
			std::vector<Node> nodes = {};

			[[nodiscard]] inline auto operator==(const Node& rhs) -> bool
			{
				return value == rhs.value and nodes == rhs.nodes;
			}

			[[nodiscard]] inline constexpr auto find(const ValueType& key) const noexcept -> auto
			{
				return std::ranges::find_if(nodes, [&key](const auto& node) -> bool {
					return node.value == key;
				});
			}

			[[nodiscard]] inline constexpr auto find(const ValueType& key) noexcept -> auto
			{
				return std::ranges::find_if(nodes, [&key](const auto& node) -> bool {
					return node.value == key;
				});
			}

			[[nodiscard]] inline constexpr auto exists(const ValueType& key) const noexcept -> bool
			{
				return find(key) != std::cend(nodes);
			}

			[[nodiscard]] inline constexpr auto operator[](const ValueType& key) -> Node&
			{
				for (auto& node : nodes)
					if (key == node.value)
						return node;
				return nodes.emplace_back(Node{key});
			}

			[[nodiscard]] inline constexpr auto operator[](const ValueType& key) const -> const Node&
			{
				const auto value = find(key);
				if (value == std::cend(nodes))
					throw std::out_of_range{"The Node does not contain the requested child."};
				return *value;
			}

			[[nodiscard]] inline constexpr auto getNodesWithValue(const ValueType& filterValue) const
			{
				return nodes | std::views::filter([&filterValue](const auto& node) { return node.value == filterValue; });
			}
		};
	};

	template<class T>
	using TreeNode = Tree<T>::Node;
}

namespace std
{
	template<class T, class CharT>
	requires CppUtils::Type::Concept::Specializes<T, CppUtils::Container::TreeNode> and
		CppUtils::Type::Concept::Printable<typename T::ValueType>
	struct formatter<T, CharT>
	{
		constexpr auto parse(std::format_parse_context& ctx) -> auto
		{
			return std::begin(ctx);
		}

		template<class FormatContext>
		inline auto format(const T& node, FormatContext& context) const -> decltype(context.out())
		{
			auto&& out = context.out();
			formatNode(node, context);
			return std::format_to(out, "\n");
		}

	private:
		template<class FormatContext>
		inline auto formatNode(const T& node, FormatContext& context, std::string&& prefix = "") const -> void
		{
			auto&& out = context.out();
			std::format_to(out, "{}\n", node.value);
			const auto nbNodes = std::size(node.nodes);
			for (auto i = 0uz; i < nbNodes; ++i)
			{
				std::format_to(out, "{}{}─ ", prefix, (i != nbNodes - 1) ? "├" : "└");
				formatNode(node.nodes.at(i), context, prefix + ((i != nbNodes - 1) ? "│" : " ") + "  ");
			}
		}
	};
}

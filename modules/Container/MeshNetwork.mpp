export module CppUtils.Container.MeshNetwork;

import std;
import CppUtils.Container.NetworkPtr;
import CppUtils.Container.SafeShared;
import CppUtils.Thread.UniqueLocker;
import CppUtils.Thread.SharedLocker;
import CppUtils.Thread.SharedPtr;

export namespace CppUtils::Container
{
	template<class Key, class Value>
	struct MeshNode final
	{
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;
		using WeakPtr = NetworkPtr::WeakPtr;
		using Accessor = NetworkPtr::Accessor;

		explicit inline MeshNode(auto&&... args):
			value{std::forward<decltype(args)>(args)...}
		{}

		static inline auto attach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			node0Ref.attachChild(node1, node1Ref);
			node0Ref.value.branches[key1].push_back(node1);
		}

		static inline auto detach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			auto& branches = node0Ref.value.branches;
			if (auto branchIt = branches.find(key1); branchIt != std::cend(branches))
			{
				auto& children = branchIt->second;
				if (auto childIt = std::find_if(std::cbegin(children), std::cend(children), [&](const auto& child) -> bool {
					return SafeShared{child} == node1;
				});
					childIt != std::cend(children))
					children.erase(childIt);
				if (std::empty(children))
					branches.erase(branchIt);
			}
			node0Ref.detachChild(node1, node1Ref);
		}

		static inline auto detach(SharedPtr& node, const Key& key) -> void
		{
			const auto nodesToDetach = [&node, &key] -> std::vector<WeakPtr> {
				auto nodeAccessor = node->uniqueAccess();
				auto& branches = nodeAccessor->value.branches;
				auto branch = branches[key];
				branches.erase(key);
				return branch;
			}();
			for (const auto& nodeToDetach : nodesToDetach)
				if (auto sharedNode = nodeToDetach.lock())
				{
					auto accessor = Thread::MultipleAccessor{*node, *sharedNode};
					auto& parentRef = std::get<0>(accessor.values);
					auto& childRef = std::get<1>(accessor.values);
					parentRef.detachChild(sharedNode, childRef);
				}
		}

		static inline auto attach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			if (node0->sharedAccess()->getDistanceFromRoot() == std::numeric_limits<std::size_t>::max())
			{
				attach(node1, key0, node0);
				attach(node0, key1, node1);
			}
			else
			{
				attach(node0, key1, node1);
				attach(node1, key0, node0);
			}
		}

		static inline auto detach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			detach(node0, key1, node1);
			detach(node1, key0, node0);
		}

		Value value;
		std::unordered_map<Key, std::vector<WeakPtr>> branches;
	};

	template<class Key, class Value>
	class MeshNodePtr final
	{
	public:
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;

		template<class NodePtrType>
		class Branch final
		{
		public:
			using ChildrenVector = std::vector<typename MeshNode<Key, Value>::WeakPtr>;

			class BranchIterator final
			{
			public:
				using iterator_category = std::input_iterator_tag;
				using value_type = MeshNodePtr<Key, Value>;
				using difference_type = std::ptrdiff_t;
				using pointer = value_type*;
				using reference = value_type&;
				using internal_iterator_type = std::vector<typename MeshNode<Key, Value>::WeakPtr>::const_iterator;

				BranchIterator() = default;
				BranchIterator(internal_iterator_type iterator): m_iterator{iterator} {}

				[[nodiscard]] auto operator*() const -> MeshNodePtr<Key, Value>
				{
					return MeshNodePtr<Key, Value>{m_iterator->lock()};
				}

				auto operator++() -> BranchIterator&
				{
					++m_iterator;
					return *this;
				}

				auto operator++(int) -> BranchIterator
				{
					BranchIterator temp = *this;
					++(*this);
					return temp;
				}

				[[nodiscard]] auto operator==(const BranchIterator& other) const -> bool
				{
					return m_iterator == other.m_iterator;
				}

				[[nodiscard]] auto operator!=(const BranchIterator& other) const -> bool
				{
					return !(*this == other);
				}

			private:
				internal_iterator_type m_iterator;
			};

			Branch(NodePtrType& self, const Key& key, ChildrenVector children): m_self(self), m_key(key), m_children(std::move(children))
			{}

			[[nodiscard]] auto begin() const -> BranchIterator
			{
				return BranchIterator{std::cbegin(m_children)};
			}

			[[nodiscard]] auto end() const -> BranchIterator
			{
				return BranchIterator{std::cend(m_children)};
			}

			[[nodiscard]] auto size() const -> std::size_t
			{
				return std::size(m_children);
			}

			[[nodiscard]] auto empty() const -> bool
			{
				return std::empty(m_children);
			}

			auto clear() -> void
			{
				if constexpr (not std::is_const_v<NodePtrType>)
				{
					for (const auto& weakChild : m_children)
						if (auto child = weakChild.lock())
							MeshNode<Key, Value>::detach(m_self.get(), m_key, child);
				}
				else
					throw std::logic_error{"Cannot clear a const branch"};
			}

			auto erase() -> void
			{
				if constexpr (not std::is_const_v<NodePtrType>)
					MeshNode<Key, Value>::detach(m_self.get(), m_key);
				else
					throw std::logic_error{"Cannot erase a const branch"};
			}

			auto operator>>(MeshNodePtr<Key, Value>& other) -> MeshNodePtr<Key, Value>&
			{
				if constexpr (not std::is_const_v<NodePtrType>)
				{
					MeshNode<Key, Value>::attach(m_self.get(), m_key, other.get());
					return other;
				}
				else
					throw std::logic_error{"Cannot attach to a const branch"};
			}

			auto operator>>(Branch<NodePtrType>&& otherBranch) -> Branch<NodePtrType>&&
			{
				if constexpr (not std::is_const_v<NodePtrType>)
				{
					MeshNode<Key, Value>::attach(m_self.get(), m_key, otherBranch.m_self.get());
					return std::move(otherBranch);
				}
				else
					throw std::logic_error{"Cannot attach to a const branch"};
			}

			auto operator-(MeshNodePtr<Key, Value>& other) -> void
			{
				if constexpr (not std::is_const_v<NodePtrType>)
					MeshNode<Key, Value>::detach(m_self.get(), m_key, other.get());
				else
					throw std::logic_error{"Cannot detach from a const branch"};
			}

			auto operator&(const Branch<NodePtrType>& other) -> void
			{
				if constexpr (not std::is_const_v<NodePtrType>)
				{
					auto node1 = MeshNodePtr{m_self.get()};
					auto node2 = MeshNodePtr{other.m_self.get()};
					MeshNode<Key, Value>::attach(other.m_key, node1.get(), m_key, node2.get());
				}
				else
					throw std::logic_error{"Cannot attach to a const branch"};
			}

			auto operator/(const Branch<NodePtrType>& other) -> void
			{
				if constexpr (not std::is_const_v<NodePtrType>)
				{
					auto node1 = MeshNodePtr{m_self.get()};
					auto node2 = MeshNodePtr{other.m_self.get()};
					MeshNode<Key, Value>::detach(other.m_key, node1.get(), m_key, node2.get());
				}
				else
					throw std::logic_error{"Cannot detach from a const branch"};
			}

			[[nodiscard]] auto operator[](std::size_t index) const -> std::expected<MeshNodePtr, std::string_view>
			{
				using namespace std::literals;

				if (index >= std::size(m_children))
					return std::unexpected{"Branch index out of bounds"sv};
				if (auto sharedChild = m_children[index].lock())
					return MeshNodePtr{sharedChild};
				return std::unexpected{"Failed to lock weak pointer for branch. Node might have been deleted"sv};
			}

		private:
			NodePtrType& m_self;
			const Key& m_key;
			ChildrenVector m_children;
		};

		[[nodiscard]] static auto makeRoot(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::makeRoot(std::forward<decltype(args)>(args)...)};
		}

		[[nodiscard]] static auto make(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::make(std::forward<decltype(args)>(args)...)};
		}

		MeshNodePtr() = default;
		MeshNodePtr(const SharedPtr& node): m_node(node) {}
		MeshNodePtr(SharedPtr&& node): m_node(std::move(node)) {}

		explicit operator bool() const noexcept
		{
			return m_node != nullptr;
		}

		[[nodiscard]] auto operator[](const Key& key) -> Branch<MeshNodePtr<Key, Value>>
		{
			if (not m_node)
				throw std::runtime_error{"Invalid MeshNodePtr: cannot access branch on a null node"};

			auto uniqueLocker = m_node->uniqueAccess();
			auto& branches = uniqueLocker->value.branches;
			return Branch{*this, key, branches[key]};
		}

		[[nodiscard]] auto at(const Key& key) const -> Branch<const MeshNodePtr<Key, Value>>
		{
			if (not m_node)
				throw std::runtime_error{"Invalid MeshNodePtr: cannot access branch on a null node"};

			auto sharedLocker = m_node->sharedAccess();
			const auto& branches = sharedLocker->value.branches;
			if (auto iterator = branches.find(key); iterator != std::cend(branches))
				return Branch{*this, key, iterator->second};
			throw std::out_of_range{"Key not found in MeshNodePtr branches"};
		}

		[[nodiscard]] auto contains(const Key& key) const -> bool
		{
			if (not m_node)
				return false;

			auto sharedLocker = m_node->sharedAccess();
			const auto& branches = sharedLocker->value.branches;
			return branches.contains(key);
		}

		[[nodiscard]] auto operator->(this auto&& self)
		{
			return self.m_node.get();
		}

		[[nodiscard]] auto operator*(this auto&& self) -> decltype(auto)
		{
			return *self.m_node;
		}

		[[nodiscard]] auto get(this auto&& self) -> decltype(auto)
		{
			return (self.m_node);
		}

		auto setValue(Value&& value) -> void
		{
			if (not m_node)
				return;
			auto uniqueLocker = m_node->uniqueAccess();
			uniqueLocker->value.value = std::forward<Value>(value);
		}

		[[nodiscard]] auto getValue() const -> std::expected<Value, std::string_view>
		{
			using namespace std::literals;

			if (not m_node)
				return std::unexpected{"Invalid MeshNodePtr"sv};
			auto sharedLocker = m_node->sharedAccess();
			return sharedLocker->value.value;
		}

		[[nodiscard]] auto operator==(const MeshNodePtr& other) const noexcept -> bool
		{
			return Thread::SharedPtr::ownerEqual(m_node, other.m_node);
		}

	private:
		SharedPtr m_node = nullptr;
	};
}

export module CppUtils.Container.MeshNetwork;

import std;
import CppUtils.Container.NetworkPtr;
import CppUtils.Container.SafeShared;
import CppUtils.Thread.UniqueLocker;
import CppUtils.Thread.SharedLocker;

export namespace CppUtils::Container
{
	template<class Key, class Value>
	struct MeshNode final
	{
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;
		using WeakPtr = NetworkPtr::WeakPtr;
		using Accessor = NetworkPtr::Accessor;

		explicit inline MeshNode(auto&&... args):
			value{std::forward<decltype(args)>(args)...}
		{}

		static inline auto attach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = CppUtils::Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			node0Ref.attachChild(node1, node1Ref);
			node0Ref.value.branches[key1].push_back(node1);
		}

		static inline auto detach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = CppUtils::Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			auto& branches = node0Ref.value.branches;
			if (auto branchIt = branches.find(key1); branchIt != std::cend(branches))
			{
				auto& childs = branchIt->second;
				if (auto childIt = std::find_if(std::cbegin(childs), std::cend(childs), [&](const auto& child) -> bool {
					return SafeShared{child} == node1;
				});
					childIt != std::cend(childs))
					childs.erase(childIt);
				if (std::empty(childs))
					branches.erase(branchIt);
			}
			node0Ref.detachChild(node1, node1Ref);
		}

		static inline auto detach(SharedPtr& node, const Key& key) -> void
		{
			const auto nodesToDetach = [&node, &key] -> std::vector<WeakPtr> {
				auto nodeAccessor = node->uniqueAccess();
				auto& branches = nodeAccessor->value.branches;
				auto branch = branches[key];
				branches.erase(key);
				return branch;
			}();
			for (const auto& nodeToDetach : nodesToDetach)
				if (auto sharedNode = nodeToDetach.lock())
				{
					auto accessor = CppUtils::Thread::MultipleAccessor{*node, *sharedNode};
					auto& parentRef = std::get<0>(accessor.values);
					auto& childRef = std::get<1>(accessor.values);
					parentRef.detachChild(sharedNode, childRef);
				}
		}

		static inline auto attach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			if (node0->sharedAccess()->getDistanceFromRoot() == std::numeric_limits<std::size_t>::max())
			{
				attach(node1, key0, node0);
				attach(node0, key1, node1);
			}
			else
			{
				attach(node0, key1, node1);
				attach(node1, key0, node0);
			}
		}

		static inline auto detach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			detach(node0, key1, node1);
			detach(node1, key0, node0);
		}

		Value value;
		std::unordered_map<Key, std::vector<WeakPtr>> branches;
	};

	template<class Key, class Value>
	using MeshNodePtr = NetworkPtr<MeshNode<Key, Value>>;
}

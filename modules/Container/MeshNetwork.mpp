export module CppUtils.Container.MeshNetwork;

import std;
import CppUtils.Container.NetworkPtr;
import CppUtils.Container.SafeShared;
import CppUtils.Thread.UniqueLocker;
import CppUtils.Thread.SharedLocker;

export namespace CppUtils::Container
{
	template<class Key, class Value>
	struct MeshNode final
	{
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;
		using WeakPtr = NetworkPtr::WeakPtr;
		using Accessor = NetworkPtr::Accessor;

		explicit inline MeshNode(auto&&... args):
			value{std::forward<decltype(args)>(args)...}
		{}

		static inline auto attach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			node0Ref.attachChild(node1, node1Ref);
			node0Ref.value.branches[key1].push_back(node1);
		}

		static inline auto detach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			auto& branches = node0Ref.value.branches;
			if (auto branchIt = branches.find(key1); branchIt != std::cend(branches))
			{
				auto& children = branchIt->second;
				if (auto childIt = std::find_if(std::cbegin(children), std::cend(children), [&](const auto& child) -> bool {
					return SafeShared{child} == node1;
				});
					childIt != std::cend(children))
					children.erase(childIt);
				if (std::empty(children))
					branches.erase(branchIt);
			}
			node0Ref.detachChild(node1, node1Ref);
		}

		static inline auto detach(SharedPtr& node, const Key& key) -> void
		{
			const auto nodesToDetach = [&node, &key] -> std::vector<WeakPtr> {
				auto nodeAccessor = node->uniqueAccess();
				auto& branches = nodeAccessor->value.branches;
				auto branch = branches[key];
				branches.erase(key);
				return branch;
			}();
			for (const auto& nodeToDetach : nodesToDetach)
				if (auto sharedNode = nodeToDetach.lock())
				{
					auto accessor = Thread::MultipleAccessor{*node, *sharedNode};
					auto& parentRef = std::get<0>(accessor.values);
					auto& childRef = std::get<1>(accessor.values);
					parentRef.detachChild(sharedNode, childRef);
				}
		}

		static inline auto attach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			if (node0->sharedAccess()->getDistanceFromRoot() == std::numeric_limits<std::size_t>::max())
			{
				attach(node1, key0, node0);
				attach(node0, key1, node1);
			}
			else
			{
				attach(node0, key1, node1);
				attach(node1, key0, node0);
			}
		}

		static inline auto detach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			detach(node0, key1, node1);
			detach(node1, key0, node0);
		}

		Value value;
		std::unordered_map<Key, std::vector<WeakPtr>> branches;
	};

	template<class Key, class Value>
	class MeshNodePtr final
	{
	public:
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;

		class Branch final
		{
		public:
			Branch(SharedPtr& self, const Key& key): m_self(self), m_key(key) {}

			auto operator>>(MeshNodePtr<Key, Value>& other) -> MeshNodePtr<Key, Value>&
			{
				MeshNode<Key, Value>::attach(m_self, m_key, other.get());
				return other;
			}

			auto operator>>(Branch&& otherBranch) -> Branch&&
			{
				MeshNode<Key, Value>::attach(m_self, m_key, otherBranch.m_self);
				return std::move(otherBranch);
			}

			auto operator-(MeshNodePtr<Key, Value>& other) -> void
			{
				MeshNode<Key, Value>::detach(m_self, m_key, other.get());
			}

			auto operator&(const Branch& other) -> void
			{
				auto node1 = MeshNodePtr{m_self};
				auto node2 = MeshNodePtr{other.m_self};
				MeshNode<Key, Value>::attach(m_key, node1.get(), other.m_key, node2.get());
			}

			auto operator/(const Branch& other) -> void
			{
				auto node1 = MeshNodePtr{m_self};
				auto node2 = MeshNodePtr{other.m_self};
				MeshNode<Key, Value>::detach(m_key, node1.get(), other.m_key, node2.get());

				auto& node1SharedLocker = *node1.get();
				auto node1Accessor = node1SharedLocker.uniqueAccess();
				auto& node2SharedLocker = *node2.get();
				auto node2Accessor = node2SharedLocker.uniqueAccess();

				auto& node2NetworkPtr = node2Accessor.value();
				node1Accessor.operator->()->detachChild(node2.get(), node2NetworkPtr);

				auto& node1NetworkPtr = node1Accessor.value();
				node2Accessor.operator->()->detachChild(node1.get(), node1NetworkPtr);
			}

		private:
			SharedPtr& m_self;
			const Key& m_key;
		};

		[[nodiscard]] static auto makeRoot(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::makeRoot(std::forward<decltype(args)>(args)...)};
		}

		[[nodiscard]] static auto make(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::make(std::forward<decltype(args)>(args)...)};
		}

		MeshNodePtr() = default;
		MeshNodePtr(const SharedPtr& node): m_node(node) {}
		MeshNodePtr(SharedPtr&& node): m_node(std::move(node)) {}

		explicit operator bool() const noexcept
		{
			return m_node != nullptr;
		}

		[[nodiscard]] auto operator[](const Key& key) -> Branch
		{
			return Branch{m_node, key};
		}

		[[nodiscard]] auto operator->(this auto&& self)
		{
			return self.m_node.get();
		}

		[[nodiscard]] auto operator*(this auto&& self) -> decltype(auto)
		{
			return *self.m_node;
		}

		[[nodiscard]] auto get(this auto&& self) -> decltype(auto)
		{
			return (self.m_node);
		}

	private:
		SharedPtr m_node = nullptr;
	};
}

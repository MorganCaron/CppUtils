export module CppUtils.Container.MeshNetwork;

import std;
import CppUtils.Container.NetworkPtr;
import CppUtils.Container.SafeShared;
import CppUtils.Thread.UniqueLocker;
import CppUtils.Thread.SharedLocker;
import CppUtils.Thread.SharedPtr;

export namespace CppUtils::Container
{
	template<class Key, class Value>
	struct MeshNode final
	{
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;
		using WeakPtr = NetworkPtr::WeakPtr;
		using Accessor = NetworkPtr::Accessor;

		explicit inline MeshNode(auto&&... args):
			value{std::forward<decltype(args)>(args)...}
		{}

		static inline auto attach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			node0Ref.attachChild(node1, node1Ref);
			node0Ref.value.branches[key1].push_back(node1);
		}

		static inline auto detach(SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			auto accessor = Thread::MultipleAccessor{*node0, *node1};
			auto& node0Ref = std::get<0>(accessor.values);
			auto& node1Ref = std::get<1>(accessor.values);

			auto& branches = node0Ref.value.branches;
			if (auto branchIt = branches.find(key1); branchIt != std::cend(branches))
			{
				auto& children = branchIt->second;
				if (auto childIt = std::find_if(std::cbegin(children), std::cend(children), [&](const auto& child) -> bool {
					return SafeShared{child} == node1;
				});
					childIt != std::cend(children))
					children.erase(childIt);
				if (std::empty(children))
					branches.erase(branchIt);
			}
			node0Ref.detachChild(node1, node1Ref);
		}

		static inline auto detach(SharedPtr& node, const Key& key) -> void
		{
			const auto nodesToDetach = [&node, &key] -> std::vector<WeakPtr> {
				auto nodeAccessor = node->uniqueAccess();
				auto& branches = nodeAccessor->value.branches;
				auto branch = branches[key];
				branches.erase(key);
				return branch;
			}();
			for (const auto& nodeToDetach : nodesToDetach)
				if (auto sharedNode = nodeToDetach.lock())
				{
					auto accessor = Thread::MultipleAccessor{*node, *sharedNode};
					auto& parentRef = std::get<0>(accessor.values);
					auto& childRef = std::get<1>(accessor.values);
					parentRef.detachChild(sharedNode, childRef);
				}
		}

		static inline auto attach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			if (node0->sharedAccess()->getDistanceFromRoot() == std::numeric_limits<std::size_t>::max())
			{
				attach(node1, key0, node0);
				attach(node0, key1, node1);
			}
			else
			{
				attach(node0, key1, node1);
				attach(node1, key0, node0);
			}
		}

		static inline auto detach(const Key& key0, SharedPtr& node0, const Key& key1, SharedPtr& node1) -> void
		{
			detach(node0, key1, node1);
			detach(node1, key0, node0);
		}

		Value value;
		std::unordered_map<Key, std::vector<WeakPtr>> branches;
	};

	template<class Key, class Value>
	class MeshNodePtr final
	{
	public:
		using NetworkPtr = NetworkPtr<MeshNode<Key, Value>>;
		using SharedPtr = NetworkPtr::SharedPtr;

		class Branch final
		{
		public:
			using ChildrenVector = std::vector<typename MeshNode<Key, Value>::WeakPtr>;

			Branch(SharedPtr& self, const Key& key, ChildrenVector children): m_self(self), m_key(key), m_children(std::move(children)) {}

			auto operator>>(MeshNodePtr<Key, Value>& other) -> MeshNodePtr<Key, Value>&
			{
				MeshNode<Key, Value>::attach(m_self, m_key, other.get());
				return other;
			}

			auto operator>>(Branch&& otherBranch) -> Branch&&
			{
				MeshNode<Key, Value>::attach(m_self, m_key, otherBranch.m_self);
				return std::move(otherBranch);
			}

			auto operator-(MeshNodePtr<Key, Value>& other) -> void
			{
				MeshNode<Key, Value>::detach(m_self, m_key, other.get());
			}

			auto operator&(const Branch& other) -> void
			{
				auto node1 = MeshNodePtr{m_self};
				auto node2 = MeshNodePtr{other.m_self};
				MeshNode<Key, Value>::attach(m_key, node1.get(), other.m_key, node2.get());
			}

			auto operator/(const Branch& other) -> void
			{
				auto node1 = MeshNodePtr{m_self};
				auto node2 = MeshNodePtr{other.m_self};
				MeshNode<Key, Value>::detach(m_key, node1.get(), other.m_key, node2.get());

				auto& node1SharedLocker = *node1.get();
				auto node1Accessor = node1SharedLocker.uniqueAccess();
				auto& node2SharedLocker = *node2.get();
				auto node2Accessor = node2SharedLocker.uniqueAccess();

				auto& node2NetworkPtr = node2Accessor.value();
				node1Accessor.operator->()->detachChild(node2.get(), node2NetworkPtr);

				auto& node1NetworkPtr = node1Accessor.value();
				node2Accessor.operator->()->detachChild(node1.get(), node1NetworkPtr);
			}

			[[nodiscard]] auto operator[](std::size_t index) const -> std::expected<MeshNodePtr, std::string_view>
			{
				using namespace std::literals;

				if (not m_self)
					return std::unexpected{"Invalid MeshNodePtr"sv};
				auto sharedLocker = m_self->sharedAccess();
				const auto& branches = sharedLocker->value.branches;
				if (auto it = branches.find(m_key); it != std::cend(branches))
				{
					const auto& children = it->second;
					if (index < std::size(children))
						if (auto sharedChild = children[index].lock())
							return MeshNodePtr{sharedChild};
						else
							return std::unexpected{"Failed to lock weak pointer for branch. Node might have been deleted"sv};
					else
						return std::unexpected{"Branch index out of bounds"sv};
				}
				return std::unexpected{"Branch key not found"sv};
			}

			class BranchIterator final
			{
			public:
				using iterator_category = std::input_iterator_tag;
				using value_type = MeshNodePtr<Key, Value>;
				using difference_type = std::ptrdiff_t;
				using pointer = value_type*;
				using reference = value_type&;
				using internal_iterator_type = std::vector<typename MeshNode<Key, Value>::WeakPtr>::const_iterator;

				BranchIterator() = default;
				BranchIterator(internal_iterator_type iterator): m_iterator{iterator} {}

				[[nodiscard]] auto operator*() const -> MeshNodePtr<Key, Value>
				{
					return MeshNodePtr<Key, Value>{m_iterator->lock()};
				}

				auto operator++() -> BranchIterator&
				{
					++m_iterator;
					return *this;
				}

				auto operator++(int) -> BranchIterator
				{
					BranchIterator temp = *this;
					++(*this);
					return temp;
				}

				[[nodiscard]] auto operator==(const BranchIterator& other) const -> bool
				{
					return m_iterator == other.m_iterator;
				}

				[[nodiscard]] auto operator!=(const BranchIterator& other) const -> bool
				{
					return !(*this == other);
				}

			private:
				internal_iterator_type m_iterator;
			};

			[[nodiscard]] auto begin() const -> BranchIterator
			{
				return BranchIterator{std::cbegin(m_children)};
			}

			[[nodiscard]] auto end() const -> BranchIterator
			{
				return BranchIterator{std::cend(m_children)};
			}

		private:
			SharedPtr& m_self;
			const Key& m_key;
			ChildrenVector m_children;
		};

		[[nodiscard]] static auto makeRoot(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::makeRoot(std::forward<decltype(args)>(args)...)};
		}

		[[nodiscard]] static auto make(auto&&... args) -> MeshNodePtr
		{
			return MeshNodePtr{NetworkPtr::make(std::forward<decltype(args)>(args)...)};
		}

		MeshNodePtr() = default;
		MeshNodePtr(const SharedPtr& node): m_node(node) {}
		MeshNodePtr(SharedPtr&& node): m_node(std::move(node)) {}

		explicit operator bool() const noexcept
		{
			return m_node != nullptr;
		}

		[[nodiscard]] auto operator[](const Key& key) -> Branch
		{
			if (not m_node)
				return Branch{m_node, key, {}};

			auto sharedLocker = m_node->sharedAccess();
			const auto& branches = sharedLocker->value.branches;
			if (auto iterator = branches.find(key); iterator != std::cend(branches))
				return Branch{m_node, key, iterator->second};
			return Branch{m_node, key, {}};
		}

		[[nodiscard]] auto contains(const Key& key) const -> bool
		{
			if (not m_node)
				return false;

			auto sharedLocker = m_node->sharedAccess();
			const auto& branches = sharedLocker->value.branches;
			return branches.contains(key);
		}

		[[nodiscard]] auto operator->(this auto&& self)
		{
			return self.m_node.get();
		}

		[[nodiscard]] auto operator*(this auto&& self) -> decltype(auto)
		{
			return *self.m_node;
		}

		[[nodiscard]] auto get(this auto&& self) -> decltype(auto)
		{
			return (self.m_node);
		}

		auto setValue(Value&& value) -> void
		{
			if (not m_node)
				return;
			auto uniqueLocker = m_node->uniqueAccess();
			uniqueLocker->value.value = std::forward<Value>(value);
		}

		[[nodiscard]] auto getValue() const -> std::expected<Value, std::string_view>
		{
			using namespace std::literals;

			if (not m_node)
				return std::unexpected{"Invalid MeshNodePtr"sv};
			auto sharedLocker = m_node->sharedAccess();
			return sharedLocker->value.value;
		}

		[[nodiscard]] auto operator==(const MeshNodePtr& other) const noexcept -> bool
		{
			return Thread::SharedPtr::ownerEqual(m_node, other.m_node);
		}

	private:
		SharedPtr m_node = nullptr;
	};
}

export module CppUtils.Execution.EventSystem;

import std;
import CppUtils.Type.Callable;
import CppUtils.String.Hash;

export namespace CppUtils::Execution
{
	class EventSystem final
	{
		using Key = std::pair<String::Hash, std::type_index>;

	public:
		template<String::Hasher eventName = String::Hash{}>
		inline auto emit(const auto& event) -> void
		{
			using Event = std::remove_cvref_t<decltype(event)>;
			auto lockGuard = std::shared_lock{m_mutex};

			auto key = std::make_pair(static_cast<String::Hash>(eventName), std::type_index{typeid(Event)});
			if (auto subscriberIt = m_subscribers.find(key); subscriberIt == std::cend(m_subscribers))
				return;
			else
				for (auto& function : subscriberIt->second)
					function(std::addressof(event));
		}

		template<String::Hasher eventName = String::Hash{}>
		inline auto subscribe(auto&& function) -> void
		{
			using FunctionType = std::decay_t<decltype(function)>;
			using FunctionInformations = Type::CallableTrait<FunctionType>;
			using ArgumentsTypes = FunctionInformations::ArgumentsTypes;
			constexpr auto nbArguments = std::tuple_size_v<ArgumentsTypes>;
			static_assert(nbArguments == 1, "EventSystem: subscribed callable must take exactly one argument");
			using Event = std::remove_cvref_t<std::tuple_element_t<0, ArgumentsTypes>>;

			auto lockGuard = std::unique_lock{m_mutex};
			auto key = std::make_pair(static_cast<String::Hash>(eventName), std::type_index{typeid(Event)});

			m_subscribers[key].emplace_back(
				[function = std::forward<decltype(function)>(function)](const void* baseEvent) -> void {
				const Event& event = *static_cast<const Event*>(baseEvent);
				function(event);
			});
		}

	private:
		struct PairHasher final
		{
			[[nodiscard]] inline auto operator()(const Key& key) const noexcept -> std::size_t
			{
				return std::hash<String::Hash>{}(key.first) ^ (key.second.hash_code() << 1);
			}
		};

		std::shared_mutex m_mutex;
		std::unordered_map<Key, std::vector<std::function<void(const void*)>>, PairHasher> m_subscribers;
	};
}

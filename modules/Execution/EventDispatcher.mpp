export module CppUtils.Execution.EventDispatcher;

import std;
import CppUtils.Type.Callable;
import CppUtils.String.Hash;

export namespace CppUtils::Execution
{
	class EventDispatcher final
	{
		using Key = std::pair<String::Hash, std::type_index>;

	public:
		template<String::Hasher eventName = String::Hash{}, class... Args>
		inline auto emit(const Args&... args) -> void
		{
			auto lockGuard = std::shared_lock{m_mutex};
			using Tuple = std::tuple<std::remove_cvref_t<Args>...>;
			auto key = std::make_pair(static_cast<String::Hash>(eventName), std::type_index{typeid(Tuple)});
			if (auto subscriberIt = m_subscribers.find(key); subscriberIt != std::cend(m_subscribers))
			{
				auto payload = std::make_tuple(args...);
				for (auto& function : subscriberIt->second)
					function(&payload);
			}
		}

		template<String::Hasher eventName = String::Hash{}>
		inline auto subscribe(auto&& function) -> void
		{
			using FunctionType = std::decay_t<decltype(function)>;
			using ArgumentsTypes = typename Type::CallableTrait<FunctionType>::ArgumentsTypes;
			[&]<class... Args>(std::tuple<Args...>*) {
				using Tuple = std::tuple<std::remove_cvref_t<Args>...>;
				auto lockGuard = std::unique_lock{m_mutex};
				auto key = std::make_pair(static_cast<String::Hash>(eventName), std::type_index{typeid(Tuple)});
				m_subscribers[key].emplace_back(
					[function = std::forward<decltype(function)>(function)](const void* payload) -> void {
					const auto& args = *static_cast<const Tuple*>(payload);
					std::apply(function, args);
				});
			}(static_cast<ArgumentsTypes*>(nullptr));
		}

	private:
		struct PairHasher final
		{
			[[nodiscard]] inline auto operator()(const Key& key) const noexcept -> std::size_t
			{
				return std::hash<String::Hash>{}(key.first) ^ (key.second.hash_code() << 1);
			}
		};

		std::shared_mutex m_mutex;
		std::unordered_map<Key, std::vector<std::function<void(const void*)>>, PairHasher> m_subscribers;
	};
}

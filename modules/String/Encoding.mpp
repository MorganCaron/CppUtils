export module CppUtils.String.Encoding;

import std;

import CppUtils.Math.Binary;
import CppUtils.Container.Interval;

export namespace CppUtils::String
{
	inline constexpr auto toUtf8(char32_t codePoint, std::string&& string = {}) -> std::string
	{
		if (codePoint < 0x80)
		{
			string += static_cast<char>(codePoint);
		}
		else if (codePoint < 0x8'00)
		{
			string += static_cast<char>(0xC0 | (codePoint >> 6));
			string += static_cast<char>(0x80 | (codePoint & 0x3F));
		}
		else if (codePoint < 0x1'00'00)
		{
			string += static_cast<char>(0xE0 | (codePoint >> 12));
			string += static_cast<char>(0x80 | ((codePoint >> 6) & 0x3F));
			string += static_cast<char>(0x80 | (codePoint & 0x3F));
		}
		else if (codePoint < 0x11'00'00)
		{
			string += static_cast<char>(0xF0 | (codePoint >> 18));
			string += static_cast<char>(0x80 | ((codePoint >> 12) & 0x3F));
			string += static_cast<char>(0x80 | ((codePoint >> 6) & 0x3F));
			string += static_cast<char>(0x80 | (codePoint & 0x3F));
		}
		return string;
	}

	inline constexpr auto toUtf8(std::u32string_view unicodeString, std::string&& string = {}) -> std::string
	{
		for (const auto codePoint : unicodeString)
			string = toUtf8(codePoint, std::move(string));
		return string;
	}

	inline constexpr auto toUtf32(std::string_view text) -> std::pair<char32_t, std::size_t>
	{
		if (std::empty(text))
			return {U'\0', 0};

		auto byte1 = static_cast<unsigned char>(text[0]);
		// 1-byte sequence (0xxxxxxx)
		// 2-byte sequence (110xxxxx 10xxxxxx)
		// 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)
		// 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)
		const auto bytesConsumed =
			((byte1 & 0b1000'0000) == 0b0000'0000) ? 1uz :
			((byte1 & 0b1110'0000) == 0b1100'0000) ? 2uz :
			((byte1 & 0b1111'0000) == 0b1110'0000) ? 3uz :
			((byte1 & 0b1111'1000) == 0b1111'0000) ? 4uz :
													 0uz;

		if (bytesConsumed == 1)
			return {static_cast<char32_t>(byte1), 1uz};

		if (bytesConsumed == 0 or std::size(text) < bytesConsumed)
			return {U'ï¿½', 1};

		static constexpr auto isContinuation = [](auto byte) constexpr noexcept -> bool {
			return (byte & 0b1100'0000) == 0b1000'0000;
		};
		for (auto i = 1uz; i < bytesConsumed; ++i)
			if (not isContinuation(static_cast<unsigned char>(text[i])))
				return {U'ï¿½', 1};

		auto character = static_cast<char32_t>(byte1 & Math::makeMask<std::uint8_t>(8 - bytesConsumed - 1, Math::HorizontalAlignment::Right));
		for (auto i = 1uz; i < bytesConsumed; ++i)
			character = (character << 6) | (static_cast<unsigned char>(text[i]) & 0b0011'1111);

		return {character, bytesConsumed};
	}

	static_assert(toUtf32("A") == std::pair{U'A', 1uz});
	static_assert(toUtf32("Â¢") == std::pair{U'Â¢', 2uz});
	static_assert(toUtf32("âš½") == std::pair{U'âš½', 3uz});
	static_assert(toUtf32("ðŸ˜Š") == std::pair{U'ðŸ˜Š', 4uz});

	[[nodiscard]] inline constexpr auto getDisplayWidth(char32_t character) noexcept -> std::size_t
	{
		// https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms
		// https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/WordBreakProperty.txt
		// https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c (Pas Ã  jour, il manque les emojis 0x1F300..0x1FAFF. Reprendre la substance, l'amÃ©liorer et la mettre Ã  jour)
		using Interval = Container::Interval<char32_t>;

		// Spec: https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt
		// Ces intervalles sont ceux annotÃ©es d'un "A" dans la spec
		// clang-format off
		constexpr static auto nonSpacingCharactersIntervals = std::array{
			Interval{0x0300, 0x036F}, Interval{0x0483, 0x0486}, Interval{0x0488, 0x0489},
			Interval{0x0591, 0x05BD}, Interval{0x05BF, 0x05BF}, Interval{0x05C1, 0x05C2},
			Interval{0x05C4, 0x05C5}, Interval{0x05C7, 0x05C7}, Interval{0x0600, 0x0603},
			Interval{0x0610, 0x0615}, Interval{0x064B, 0x065E}, Interval{0x0670, 0x0670},
			Interval{0x06D6, 0x06E4}, Interval{0x06E7, 0x06E8}, Interval{0x06EA, 0x06ED},
			Interval{0x070F, 0x070F}, Interval{0x0711, 0x0711}, Interval{0x0730, 0x074A},
			Interval{0x07A6, 0x07B0}, Interval{0x07EB, 0x07F3}, Interval{0x0901, 0x0902},
			Interval{0x093C, 0x093C}, Interval{0x0941, 0x0948}, Interval{0x094D, 0x094D},
			Interval{0x0951, 0x0954}, Interval{0x0962, 0x0963}, Interval{0x0981, 0x0981},
			Interval{0x09BC, 0x09BC}, Interval{0x09C1, 0x09C4}, Interval{0x09CD, 0x09CD},
			Interval{0x09E2, 0x09E3}, Interval{0x0A01, 0x0A02}, Interval{0x0A3C, 0x0A3C},
			Interval{0x0A41, 0x0A42}, Interval{0x0A47, 0x0A48}, Interval{0x0A4B, 0x0A4D},
			Interval{0x0A70, 0x0A71}, Interval{0x0A81, 0x0A82}, Interval{0x0ABC, 0x0ABC},
			Interval{0x0AC1, 0x0AC5}, Interval{0x0AC7, 0x0AC8}, Interval{0x0ACD, 0x0ACD},
			Interval{0x0AE2, 0x0AE3}, Interval{0x0B01, 0x0B01}, Interval{0x0B3C, 0x0B3C},
			Interval{0x0B3F, 0x0B3F}, Interval{0x0B41, 0x0B43}, Interval{0x0B4D, 0x0B4D},
			Interval{0x0B56, 0x0B56}, Interval{0x0B82, 0x0B82}, Interval{0x0BC0, 0x0BC0},
			Interval{0x0BCD, 0x0BCD}, Interval{0x0C3E, 0x0C40}, Interval{0x0C46, 0x0C48},
			Interval{0x0C4A, 0x0C4D}, Interval{0x0C55, 0x0C56}, Interval{0x0CBC, 0x0CBC},
			Interval{0x0CBF, 0x0CBF}, Interval{0x0CC6, 0x0CC6}, Interval{0x0CCC, 0x0CCD},
			Interval{0x0CE2, 0x0CE3}, Interval{0x0D41, 0x0D43}, Interval{0x0D4D, 0x0D4D},
			Interval{0x0DCA, 0x0DCA}, Interval{0x0DD2, 0x0DD4}, Interval{0x0DD6, 0x0DD6},
			Interval{0x0E31, 0x0E31}, Interval{0x0E34, 0x0E3A}, Interval{0x0E47, 0x0E4E},
			Interval{0x0EB1, 0x0EB1}, Interval{0x0EB4, 0x0EB9}, Interval{0x0EBB, 0x0EBC},
			Interval{0x0EC8, 0x0ECD}, Interval{0x0F18, 0x0F19}, Interval{0x0F35, 0x0F35},
			Interval{0x0F37, 0x0F37}, Interval{0x0F39, 0x0F39}, Interval{0x0F71, 0x0F7E},
			Interval{0x0F80, 0x0F84}, Interval{0x0F86, 0x0F87}, Interval{0x0F90, 0x0F97},
			Interval{0x0F99, 0x0FBC}, Interval{0x0FC6, 0x0FC6}, Interval{0x102D, 0x1030},
			Interval{0x1032, 0x1032}, Interval{0x1036, 0x1037}, Interval{0x1039, 0x1039},
			Interval{0x1058, 0x1059}, Interval{0x1160, 0x11FF}, Interval{0x135F, 0x135F},
			Interval{0x1712, 0x1714}, Interval{0x1732, 0x1734}, Interval{0x1752, 0x1753},
			Interval{0x1772, 0x1773}, Interval{0x17B4, 0x17B5}, Interval{0x17B7, 0x17BD},
			Interval{0x17C6, 0x17C6}, Interval{0x17C9, 0x17D3}, Interval{0x17DD, 0x17DD},
			Interval{0x180B, 0x180D}, Interval{0x18A9, 0x18A9}, Interval{0x1920, 0x1922},
			Interval{0x1927, 0x1928}, Interval{0x1932, 0x1932}, Interval{0x1939, 0x193B},
			Interval{0x1A17, 0x1A18}, Interval{0x1B00, 0x1B03}, Interval{0x1B34, 0x1B34},
			Interval{0x1B36, 0x1B3A}, Interval{0x1B3C, 0x1B3C}, Interval{0x1B42, 0x1B42},
			Interval{0x1B6B, 0x1B73}, Interval{0x1DC0, 0x1DCA}, Interval{0x1DFE, 0x1DFF},
			Interval{0x200B, 0x200F}, Interval{0x202A, 0x202E}, Interval{0x2060, 0x2063},
			Interval{0x206A, 0x206F}, Interval{0x20D0, 0x20EF}, Interval{0x302A, 0x302F},
			Interval{0x3099, 0x309A}, Interval{0xA806, 0xA806}, Interval{0xA80B, 0xA80B},
			Interval{0xA825, 0xA826}, Interval{0xFB1E, 0xFB1E}, Interval{0xFE00, 0xFE0F},
			Interval{0xFE20, 0xFE23}, Interval{0xFEFF, 0xFEFF}, Interval{0xFFF9, 0xFFFB},
			Interval{0x10A01, 0x10A03}, Interval{0x10A05, 0x10A06}, Interval{0x10A0C, 0x10A0F},
			Interval{0x10A38, 0x10A3A}, Interval{0x10A3F, 0x10A3F}, Interval{0x1D167, 0x1D169},
			Interval{0x1D173, 0x1D182}, Interval{0x1D185, 0x1D18B}, Interval{0x1D1AA, 0x1D1AD},
			Interval{0x1D242, 0x1D244}, Interval{0xE0001, 0xE0001}, Interval{0xE0020, 0xE007F},
			Interval{0xE0100, 0xE01EF}
		};
		// clang-format on

		if (character < 32 or (character >= 0x7f and character < 0xa0))
			return 0uz;

		if (Container::isInside(character, nonSpacingCharactersIntervals))
			return 0uz;

		// Spec: https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt
		// Ces intervalles sont ceux annotÃ©es d'un "W" dans la spec
		// clang-format off
		constexpr static auto twoWidthCharactersIntervals = std::array{
			Interval{0x1100, 0x115F}, Interval{0x231A, 0x231B}, Interval{0x2329, 0x2329},
			Interval{0x232A, 0x232A}, Interval{0x23E9, 0x23EC}, Interval{0x23F0, 0x23F0},
			Interval{0x23F3, 0x23F3}, Interval{0x25FD, 0x25FE}, Interval{0x2614, 0x2615},
			Interval{0x2630, 0x2637}, Interval{0x2648, 0x2653}, Interval{0x267F, 0x267F},
			Interval{0x268A, 0x268F}, Interval{0x2693, 0x2693}, Interval{0x26A1, 0x26A1},
			Interval{0x26AA, 0x26AB}, Interval{0x26BD, 0x26BE}, Interval{0x26C4, 0x26C5},
			Interval{0x26CE, 0x26CE}, Interval{0x26D4, 0x26D4}, Interval{0x26EA, 0x26EA},
			Interval{0x26F2, 0x26F3}, Interval{0x26F5, 0x26F5}, Interval{0x26FA, 0x26FA},
			Interval{0x26FD, 0x26FD}, Interval{0x2705, 0x2705}, Interval{0x270A, 0x270B},
			Interval{0x2728, 0x2728}, Interval{0x274C, 0x274C}, Interval{0x274E, 0x274E},
			Interval{0x2753, 0x2755}, Interval{0x2757, 0x2757}, Interval{0x2795, 0x2797},
			Interval{0x27B0, 0x27B0}, Interval{0x27BF, 0x27BF}, Interval{0x2B1B, 0x2B1C},
			Interval{0x2B50, 0x2B50}, Interval{0x2B55, 0x2B55}, Interval{0x2E80, 0x2E99},
			Interval{0x2E9B, 0x2EF3}, Interval{0x2F00, 0x2FD5}, Interval{0x2FF0, 0x2FFF},
			Interval{0x3001, 0x303E}, Interval{0x3041, 0x3096}, Interval{0x3099, 0x30FF},
			Interval{0x3105, 0x312F}, Interval{0x3131, 0x318E}, Interval{0x3190, 0x31E5},
			Interval{0x31EF, 0x321E}, Interval{0x3220, 0x3229}, Interval{0x322A, 0x3247},
			Interval{0x3250, 0xA48C}, Interval{0xA490, 0xA4C6}, Interval{0xA960, 0xA97C},
			Interval{0xAC00, 0xD7A3}, Interval{0xF900, 0xFAFF}, Interval{0xFE10, 0xFE19},
			Interval{0xFE30, 0xFE52}, Interval{0xFE54, 0xFE66}, Interval{0xFE68, 0xFE6B},
			Interval{0x16FE0, 0x16FE4}, Interval{0x16FF0, 0x16FF6}, Interval{0x17000, 0x18CD5},
			Interval{0x18CFF, 0x18D1E}, Interval{0x18D80, 0x18DF2}, Interval{0x1AFF0, 0x1AFF3},
			Interval{0x1AFF5, 0x1AFFB}, Interval{0x1AFFD, 0x1AFFE}, Interval{0x1B000, 0x1B122},
			Interval{0x1B132, 0x1B132}, Interval{0x1B150, 0x1B152}, Interval{0x1B155, 0x1B155},
			Interval{0x1B164, 0x1B167}, Interval{0x1B170, 0x1B2FB}, Interval{0x1D300, 0x1D356},
			Interval{0x1D360, 0x1D376}, Interval{0x1F004, 0x1F004}, Interval{0x1F0CF, 0x1F0CF},
			Interval{0x1F18E, 0x1F18E}, Interval{0x1F191, 0x1F19A}, Interval{0x1F200, 0x1F202},
			Interval{0x1F210, 0x1F23B}, Interval{0x1F240, 0x1F248}, Interval{0x1F250, 0x1F251},
			Interval{0x1F260, 0x1F265}, Interval{0x1F300, 0x1F320}, Interval{0x1F32D, 0x1F335},
			Interval{0x1F337, 0x1F37C}, Interval{0x1F37E, 0x1F393}, Interval{0x1F3A0, 0x1F3CA},
			Interval{0x1F3CF, 0x1F3D3}, Interval{0x1F3E0, 0x1F3F0}, Interval{0x1F3F4, 0x1F3F4},
			Interval{0x1F3F8, 0x1F43E}, Interval{0x1F440, 0x1F440}, Interval{0x1F442, 0x1F4FC},
			Interval{0x1F4FF, 0x1F53D}, Interval{0x1F54B, 0x1F54E}, Interval{0x1F550, 0x1F567},
			Interval{0x1F57A, 0x1F57A}, Interval{0x1F595, 0x1F596}, Interval{0x1F5A4, 0x1F5A4},
			Interval{0x1F5FB, 0x1F64F}, Interval{0x1F680, 0x1F6C5}, Interval{0x1F6CC, 0x1F6CC},
			Interval{0x1F6D0, 0x1F6D2}, Interval{0x1F6D5, 0x1F6D8}, Interval{0x1F6DC, 0x1F6DF},
			Interval{0x1F6EB, 0x1F6EC}, Interval{0x1F6F4, 0x1F6FC}, Interval{0x1F7E0, 0x1F7EB},
			Interval{0x1F7F0, 0x1F7F0}, Interval{0x1F90C, 0x1F93A}, Interval{0x1F93C, 0x1F945},
			Interval{0x1F947, 0x1F9FF}, Interval{0x1FA70, 0x1FA7C}, Interval{0x1FA80, 0x1FA8A},
			Interval{0x1FA8E, 0x1FAC6}, Interval{0x1FAC8, 0x1FAC8}, Interval{0x1FACD, 0x1FADC},
			Interval{0x1FADF, 0x1FAEA}, Interval{0x1FAEF, 0x1FAF8}, Interval{0x20000, 0x2FFFD},
			Interval{0x30000, 0x3FFFD}
		};
		// clang-format on

		if (Container::isInside(character, twoWidthCharactersIntervals))
			return 2uz;

		return 1uz;
	}

	[[nodiscard]] inline constexpr auto getDisplayWidth(std::u32string_view unicodeString) -> std::size_t
	{
		auto width = 0uz;
		for (const auto character : unicodeString)
			width += getDisplayWidth(character);
		return width;
	}

	static_assert(getDisplayWidth(std::u32string_view{U"âš½"}) == 2);
	static_assert(getDisplayWidth(std::u32string_view{U"ðŸ˜Š"}) == 2);
}

module;

#include <CppUtils/System/OS.hpp>

#if defined(OS_LINUX)
#	include <cerrno>
#	include <unistd.h>
#	include <sys/epoll.h>
#	include <sys/inotify.h>
#endif

export module CppUtils.FileSystem.FileWatcher;

import std;
import CppUtils.Chrono;
import CppUtils.Container;
import CppUtils.FileSystem.File;
import CppUtils.System;
import CppUtils.Thread;
import CppUtils.Type;

/* Todo:
Windows: FindFirstChangeNotification -> https://learn.microsoft.com/fr-fr/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa?redirectedfrom=MSDN
MacOS: kqueue -> https://man.freebsd.org/cgi/man.cgi?kqueue
Linux: inotify -> https://man7.org/linux/man-pages/man7/inotify.7.html
*/
export namespace CppUtils::FileSystem
{
	namespace v2
	{
		enum FileStatus : std::uint8_t
		{
			Created = 0b1,
			Modified = 0b10,
			Deleted = 0b100
		};

		using WatchedFileStatus = std::uint8_t;

		inline constexpr auto allFileStatus = WatchedFileStatus{
			FileStatus::Created |
			FileStatus::Modified |
			FileStatus::Deleted};

		class FileWatcher final
		{
		public:
			using SubscribeFunction = std::function<void(const std::filesystem::path&, FileStatus)>;

			inline FileWatcher()
			{
				start();
			}

			inline ~FileWatcher()
			{
				stop();
			}

			inline auto start() -> void
			{
#if defined(OS_LINUX)
				m_inotifyFileDescriptor = inotify_init1(IN_NONBLOCK);
				m_eventPollFileDescriptor = epoll_create1(0);
				m_event.events = EPOLLIN | EPOLLET;
				m_event.data.fd = m_inotifyFileDescriptor;
				System::checkErrno(
					epoll_ctl(m_eventPollFileDescriptor, EPOLL_CTL_ADD, m_inotifyFileDescriptor, &m_event),
					"Can't add inotify file descriptor to epoll");
#endif
			}

			inline auto stop() -> void
			{
#if defined(OS_LINUX)
				epoll_ctl(m_eventPollFileDescriptor, EPOLL_CTL_DEL, m_inotifyFileDescriptor, 0);
				m_inotifyFileDescriptor.close();
				m_eventPollFileDescriptor.close();
#endif
			}

			inline auto watchFile(const std::filesystem::path& filePath) -> void
			{
				if (not std::filesystem::exists(filePath))
					return;
#if defined(OS_LINUX)
				auto watchDescriptor = System::checkErrno(
					inotify_add_watch(m_inotifyFileDescriptor, filePath.string().c_str(), m_eventMask),
					std::format("Failed to watch the file {}", filePath.string()));
				m_watchDescriptors.insert({filePath, watchDescriptor});
#endif
			}

			inline auto unwatchFile([[maybe_unused]] const std::filesystem::path& filePath) -> void
			{
#if defined(OS_LINUX)
				System::checkErrno(
					inotify_rm_watch(m_inotifyFileDescriptor, m_watchDescriptors.left[filePath]),
					std::format("Failed to stop watching the file {}", filePath.string()));
				m_watchDescriptors.eraseLeft(filePath);
#endif
			}

			inline auto watchDirectory(
				const std::filesystem::path& directoryPath,
				bool recursively) -> void
			{
				if (std::filesystem::exists(directoryPath))
					watchFile(directoryPath);
				forFiles(directoryPath, [this](const auto& filePath) -> void {
					watchFile(filePath);
				}, recursively);
			}

			[[nodiscard]] inline auto isRunning() const noexcept -> bool
			{
#if defined(OS_LINUX)
				return m_inotifyFileDescriptor != -1;
#endif
				return false;
			}

		private:
#if defined(OS_LINUX)
			System::FileDescriptor m_inotifyFileDescriptor;
			System::FileDescriptor m_eventPollFileDescriptor;
			epoll_event m_event;
			std::uint32_t m_eventMask;
			using WatchDescriptor = int;
			Container::BidirectionalMap<std::filesystem::path, WatchDescriptor> m_watchDescriptors;
#endif
		};
	}

	inline namespace v1
	{
		enum FileStatus : std::uint8_t
		{
			Created = 0b1,
			Modified = 0b10,
			Deleted = 0b100
		};

		using WatchedFileStatus = std::uint8_t;

		inline constexpr auto allFileStatus = WatchedFileStatus{
			FileStatus::Created |
			FileStatus::Modified |
			FileStatus::Deleted};

		class FileWatcher final
		{
		public:
			using SubscribeFunction = std::function<void(const std::filesystem::path&, FileStatus)>;

		private:
			struct FileInfos final
			{
				inline FileInfos() = default;
				inline explicit FileInfos(const std::filesystem::path& c_path)
				{
					path = c_path;
					exists = std::filesystem::exists(path);
					auto errorCode = std::error_code{};
					lastWriteTime = exists ?
						std::filesystem::last_write_time(path, errorCode) :
						std::filesystem::file_time_type{};
				}

				std::filesystem::path path;
				bool exists;
				std::filesystem::file_time_type lastWriteTime;
			};

			struct WatchFileOptions
			{
				SubscribeFunction subscribedFunction;
				WatchedFileStatus watchStatus;
			};

			struct WatchDirectoryOptions final: public WatchFileOptions
			{
				inline WatchDirectoryOptions() = default;
				inline WatchDirectoryOptions(SubscribeFunction subscribedFunction, WatchedFileStatus watchStatus, bool recursively):
					WatchFileOptions{subscribedFunction, watchStatus},
					recursively{recursively},
					firstScan{true}
				{}

				bool recursively;
				bool firstScan;
			};

			struct WatchedFile final
			{
				inline WatchedFile() = default;
				inline WatchedFile(const std::filesystem::path& path, WatchFileOptions options):
					infos{path},
					options{options}
				{}

				FileInfos infos;
				WatchFileOptions options;
			};

			using FilesInfos = std::unordered_map<std::filesystem::path, FileInfos>;

			struct WatchedDirectory final
			{
				inline WatchedDirectory() = default;
				inline WatchedDirectory(const std::filesystem::path& path, WatchDirectoryOptions options):
					path{path},
					filesInfos{},
					options{options}
				{}

				std::filesystem::path path;
				FilesInfos filesInfos;
				WatchDirectoryOptions options;
			};

			using WatchedFiles = std::unordered_map<std::filesystem::path, WatchedFile>;
			using WatchedDirectories = std::unordered_map<std::filesystem::path, WatchedDirectory>;

		public:
			inline FileWatcher() = delete;

			template<Chrono::Concept::Duration Duration = std::chrono::seconds>
			inline explicit FileWatcher(Duration&& interval):
				m_loopThread{std::bind(&FileWatcher::listener, this), nullptr, interval}
			{}

			inline ~FileWatcher()
			{
				stop();
			}

			[[nodiscard]] inline auto isRunning() const noexcept -> bool
			{
				return m_loopThread.isRunning();
			}

			template<Chrono::Concept::Duration Duration = std::chrono::seconds>
			inline auto start(Duration&& interval = Duration{1}) -> void
			{
				m_loopThread.start(interval);
			}

			inline auto stop() -> void
			{
				m_loopThread.stop();
			}

			inline auto watchFile(
				const std::filesystem::path& filePath,
				SubscribeFunction function,
				WatchedFileStatus watchStatus = allFileStatus) -> void
			{
				[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
				m_watchedFiles[filePath] = WatchedFile{filePath, WatchFileOptions{std::move(function), watchStatus}};
			}

			inline auto unwatchFile(const std::filesystem::path& filePath) -> void
			{
				[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
				m_watchedFiles.erase(filePath);
			}

			inline auto watchDirectory(
				const std::filesystem::path& directory,
				SubscribeFunction function,
				WatchedFileStatus watchStatus = allFileStatus,
				bool recursively = true) -> void
			{
				[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
				m_watchedDirectories[directory] = WatchedDirectory{directory,
					WatchDirectoryOptions{std::move(function), watchStatus, recursively}};
			}

			inline auto unwatchDirectory(const std::filesystem::path& directory) -> void
			{
				[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
				m_watchedDirectories.erase(directory);
			}

		private:
			inline auto checkFile(FileInfos& infos, const WatchFileOptions& options) -> void
			{
				auto& [path, exists, lastWriteTime] = infos;
				const auto& [subscribedFunction, watchStatus] = options;
				if (std::filesystem::exists(path))
				{
					auto errorCode = std::error_code{};
					auto currentLastWriteTime = std::filesystem::last_write_time(path, errorCode);
					if (errorCode)
						return;
					if (not exists)
					{
						lastWriteTime = currentLastWriteTime;
						exists = true;
						if (watchStatus & FileStatus::Created)
							subscribedFunction(path, FileStatus::Created);
					}
					else if (lastWriteTime != currentLastWriteTime)
					{
						lastWriteTime = currentLastWriteTime;
						if (watchStatus & FileStatus::Modified)
							subscribedFunction(path, FileStatus::Modified);
					}
				}
				else if (exists)
				{
					exists = false;
					if (watchStatus & FileStatus::Deleted)
						subscribedFunction(path, FileStatus::Deleted);
				}
			}

			inline auto checkDirectory(WatchedDirectory& watchedDirectory) -> void
			{
				auto& [directoryPath, filesInfos, options] = watchedDirectory;
				forFiles(directoryPath, [&filesInfos, &options](const auto& filePath) -> void {
					if (auto fileInfosIt = filesInfos.find(filePath); fileInfosIt == std::cend(filesInfos))
					{
						fileInfosIt = filesInfos.emplace(std::make_pair(filePath, FileInfos{filePath})).first;
						if (not options.firstScan)
							fileInfosIt->second.exists = false;
					}
				}, options.recursively);
				if (options.firstScan)
					options.firstScan = false;
				auto filesToUnwatch = std::vector<std::filesystem::path>{};
				for (auto& [filePath, fileInfos] : filesInfos)
				{
					checkFile(fileInfos, options);
					if (not std::filesystem::exists(filePath))
						filesToUnwatch.push_back(filePath);
				}
				for (const auto& fileToUnwatch : filesToUnwatch)
					filesInfos.erase(fileToUnwatch);
			}

			inline auto listener() -> void
			{
				[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
				for (auto& [filePath, watchedFile] : m_watchedFiles)
					checkFile(watchedFile.infos, watchedFile.options);
				for (auto& [directory, WatchedDirectory] : m_watchedDirectories)
					checkDirectory(WatchedDirectory);
			}

			std::mutex m_mutex;
			WatchedFiles m_watchedFiles;
			WatchedDirectories m_watchedDirectories;
			Thread::LoopThread m_loopThread;
		};
	}
}

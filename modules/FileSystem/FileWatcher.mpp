export module CppUtils.FileSystem.FileWatcher;

import std;
import CppUtils.Chrono;
import CppUtils.FileSystem.File;
import CppUtils.Thread;
import CppUtils.Type;

export namespace CppUtils::FileSystem
{
	enum FileStatus : std::uint8_t
	{
		Created = 0b1,
		Modified = 0b10,
		Deleted = 0b100
	};

	using WatchedFileStatus = std::uint8_t;

	inline constexpr auto allFileStatus = WatchedFileStatus{
		FileStatus::Created |
		FileStatus::Modified |
		FileStatus::Deleted};

	class FileWatcher final
	{
	public:
		using SubscribeFunction = std::function<void(const std::filesystem::path&, FileStatus)>;

	private:
		struct FileInfos final
		{
			inline FileInfos() = default;
			inline explicit FileInfos(const std::filesystem::path& c_path)
			{
				path = c_path;
				exists = std::filesystem::exists(path);
				auto errorCode = std::error_code{};
				lastWriteTime = exists ?
					std::filesystem::last_write_time(path, errorCode) :
					std::filesystem::file_time_type{};
			}

			std::filesystem::path path;
			bool exists;
			std::filesystem::file_time_type lastWriteTime;
		};

		struct WatchFileOptions
		{
			SubscribeFunction subscribedFunction;
			WatchedFileStatus watchStatus;
		};

		struct WatchDirectoryOptions final: public WatchFileOptions
		{
			inline WatchDirectoryOptions() = default;
			inline WatchDirectoryOptions(SubscribeFunction subscribedFunction, WatchedFileStatus watchStatus, bool recursively):
				WatchFileOptions{subscribedFunction, watchStatus},
				recursively{recursively},
				firstScan{true}
			{}

			bool recursively;
			bool firstScan;
		};

		struct WatchedFile final
		{
			inline WatchedFile() = default;
			inline WatchedFile(const std::filesystem::path& path, WatchFileOptions options):
				infos{path},
				options{options}
			{}

			FileInfos infos;
			WatchFileOptions options;
		};

		using FilesInfos = std::unordered_map<std::filesystem::path, FileInfos>;

		struct WatchedDirectory final
		{
			inline WatchedDirectory() = default;
			inline WatchedDirectory(const std::filesystem::path& path, WatchDirectoryOptions options):
				path{path},
				filesInfos{},
				options{options}
			{}

			std::filesystem::path path;
			FilesInfos filesInfos;
			WatchDirectoryOptions options;
		};

		using WatchedFiles = std::unordered_map<std::filesystem::path, WatchedFile>;
		using WatchedDirectories = std::unordered_map<std::filesystem::path, WatchedDirectory>;

	public:
		inline FileWatcher() = delete;

		template<Chrono::Concept::Duration Duration = std::chrono::seconds>
		inline explicit FileWatcher(Duration&& interval):
			m_loopThread{std::bind(&FileWatcher::listener, this), nullptr, interval}
		{}

		inline ~FileWatcher()
		{
			stop();
		}

		[[nodiscard]] inline auto isRunning() const noexcept -> bool
		{
			return m_loopThread.isRunning();
		}

		template<Chrono::Concept::Duration Duration = std::chrono::seconds>
		inline auto start(Duration&& interval = Duration{1}) -> void
		{
			m_loopThread.start(interval);
		}

		inline auto stop() -> void
		{
			m_loopThread.stop();
		}

		inline auto watchFile(
			const std::filesystem::path& filePath,
			SubscribeFunction function,
			WatchedFileStatus watchStatus = allFileStatus) -> void
		{
			[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
			m_watchedFiles[filePath] = WatchedFile{filePath, WatchFileOptions{std::move(function), watchStatus}};
		}

		inline auto unwatchFile(const std::filesystem::path& filePath) -> void
		{
			[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
			m_watchedFiles.erase(filePath);
		}

		inline auto watchDirectory(
			const std::filesystem::path& directory,
			SubscribeFunction function,
			WatchedFileStatus watchStatus = allFileStatus,
			bool recursively = true) -> void
		{
			[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
			m_watchedDirectories[directory] = WatchedDirectory{directory,
				WatchDirectoryOptions{std::move(function), watchStatus, recursively}};
		}

		inline auto unwatchDirectory(const std::filesystem::path& directory) -> void
		{
			[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
			m_watchedDirectories.erase(directory);
		}

	private:
		inline auto checkFile(FileInfos& infos, const WatchFileOptions& options) -> void
		{
			auto& [path, exists, lastWriteTime] = infos;
			const auto& [subscribedFunction, watchStatus] = options;
			if (std::filesystem::exists(path))
			{
				auto errorCode = std::error_code{};
				auto currentLastWriteTime = std::filesystem::last_write_time(path, errorCode);
				if (errorCode)
					return;
				if (not exists)
				{
					lastWriteTime = currentLastWriteTime;
					exists = true;
					if (watchStatus & FileStatus::Created)
						subscribedFunction(path, FileStatus::Created);
				}
				else if (lastWriteTime != currentLastWriteTime)
				{
					lastWriteTime = currentLastWriteTime;
					if (watchStatus & FileStatus::Modified)
						subscribedFunction(path, FileStatus::Modified);
				}
			}
			else if (exists)
			{
				exists = false;
				if (watchStatus & FileStatus::Deleted)
					subscribedFunction(path, FileStatus::Deleted);
			}
		}

		inline auto checkDirectory(WatchedDirectory& watchedDirectory) -> void
		{
			auto& [directoryPath, filesInfos, options] = watchedDirectory;
			forFiles(directoryPath, [&filesInfos, &options](const auto& filePath) -> void {
				if (auto fileInfosIt = filesInfos.find(filePath); fileInfosIt == std::cend(filesInfos))
				{
					fileInfosIt = filesInfos.emplace(std::make_pair(filePath, FileInfos{filePath})).first;
					if (not options.firstScan)
						fileInfosIt->second.exists = false;
				}
			}, options.recursively);
			if (options.firstScan)
				options.firstScan = false;
			auto filesToUnwatch = std::vector<std::filesystem::path>{};
			for (auto& [filePath, fileInfos] : filesInfos)
			{
				checkFile(fileInfos, options);
				if (not std::filesystem::exists(filePath))
					filesToUnwatch.push_back(filePath);
			}
			for (const auto& fileToUnwatch : filesToUnwatch)
				filesInfos.erase(fileToUnwatch);
		}

		inline auto listener() -> void
		{
			[[maybe_unused]] auto lockGuard = std::unique_lock<std::mutex>{m_mutex};
			for (auto& [filePath, watchedFile] : m_watchedFiles)
				checkFile(watchedFile.infos, watchedFile.options);
			for (auto& [directory, WatchedDirectory] : m_watchedDirectories)
				checkDirectory(WatchedDirectory);
		}

		std::mutex m_mutex;
		WatchedFiles m_watchedFiles;
		WatchedDirectories m_watchedDirectories;
		Thread::LoopThread m_loopThread;
	};
}

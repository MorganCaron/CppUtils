module;

#include <cstdio>

export module CppUtils.Logger;

import std;
import CppUtils.String;
import CppUtils.Execution.EventQueue;
import CppUtils.Pattern.Multiton;
import CppUtils.Terminal.Size;
import CppUtils.Terminal.TextColor;
import CppUtils.Terminal.TextModifier;

// Todo: log le datetime
// Todo: log le stacktrace ( https://en.cppreference.com/w/cpp/utility/stacktrace_entry )

export namespace CppUtils
{
	template<String::Hasher loggerName>
	inline auto configureLogger(Execution::EventQueue& eventQueue) -> void;

	template<String::Hasher loggerName = String::Hash{}>
	struct Logger final
	{
		[[nodiscard]] static inline auto& eventQueue() noexcept
		{
			auto& eventQueue = Pattern::Multiton<Execution::EventQueue, loggerName>::get();
			[[maybe_unused]] static auto _ = (configure(eventQueue), true);
			return eventQueue;
		}

		static inline auto configure(Execution::EventQueue& eventQueue) -> void
		{
			configureLogger<loggerName>(eventQueue);
		}

		template<String::Hasher logType = String::Hash{}, class... Args>
		static inline auto emit(Args&&... args) -> void
		{
			eventQueue().template emit<logType>(std::forward<Args>(args)...);
		}

		template<class... Args>
		static inline auto emit(String::Hash logType, Args&&... args) -> void
		{
			eventQueue().emit(logType, std::forward<Args>(args)...);
		}

		template<String::Hasher logType = String::Hash{}, class... Args>
		static inline auto print(std::format_string<Args...> fmt, Args&&... args) -> void
		{
			emit<logType>(std::format(fmt, std::forward<Args>(args)...));
		}

		template<String::Hasher logType = String::Hash{}>
		static inline auto subscribe(auto&& function) -> void
		{
			eventQueue().template subscribe<logType>(std::forward<decltype(function)>(function));
		}

		static inline auto waitUntilFinished() -> void
		{
			eventQueue().waitUntilFinished();
		}
	};

	template<String::Hasher loggerName>
	inline auto configureLogger(Execution::EventQueue&) -> void
	{}
}
